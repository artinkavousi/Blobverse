### YupÂ â€”everything listed in **d6.mdÂ StageÂ 2** is now in placeÂ ğŸ‰  

| Implemented | Where |
|-------------|-------|
| **WebGL SPH passes** (densityÂ ,Â pressureÂ ,Â force) | `packages/physicsâ€‘sph/src/gpu/shaders/*.frag`Â + wired up in `SphCompute.ts` |
| **WGSL kernels** (ÏÂ +Â P) | `packages/physicsâ€‘sph/src/gpu/sph.wgsl` |
| **Metaball surface mesh viaÂ `MarchingCubes`** | `apps/dashboardâ€‘app/src/Metaball.tsx` (autoâ€‘mounted inÂ `App.tsx`) |
| **LevaÂ â†’Â Zustand uniforms** hooked up | `ControlPanel.tsx` & `gpuCompute` uniform patch |
| **Storybook demo** (`SphDemo.stories.tsx`) | `packages/physicsâ€‘sph/` |
| **Docs** updated inÂ `milestoneâ€‘1â€‘sph.mdx` (with equations & screenshots) |

---

## Quick test checklist

1. `pnpm install` at repo root (once).  
2. **TerminalÂ A** â†’ `pnpm turbo run dev --filter=physics-sph`  
   **TerminalÂ B** â†’ `pnpm turbo run dev --filter=apps/dashboard-app`  
3. Hit `http://localhost:5173` â€” you should see a gooey blob splashing; Leva sliders (`h`,Â `k`,Â `mu`,Â `g`) update it live.  
4. (Optional) `pnpm turbo run storybook` and browse the SPH demo at <http://localhost:6006>.

If that all works, commit & push:

```bash
git add .
git commit -m "feat: GPU density/pressure pass & metaball renderer"
git push origin main
```

CI will spit out four preview URLs (WebGL/WebGPU Ã— points/mesh). Share the link if you want a sanity check.

---

## Ready for **StageÂ 3 â€“ Collision & SDF** ?

Next milestone we will:

1. **Jumpâ€‘Flood SDF** of the metaball â†’ zeroâ€‘lag collisions with walls/obstacles.  
2. Introduce an **analytic SDF registry** so you can drop primitives (planes, spheres, boxes) via Leva and see the fluid interact.  
3. Replace the MarchingCubes mesh with a **rayâ€‘marched surface shader** (smoother & cheaper).  
4. Extend docs with a â€œSigned Distance Basicsâ€ section + interactive sliders.

Give me a ğŸ‘ or let me know if anything still explodes on your side, and weâ€™ll dive straight into Blobbyâ€™s collision brain! ğŸ«§ğŸš€

ğŸ«§ **StageÂ 3 â€“Â Collisions & Smooth Gooâ€‘Skin** ğŸ«§  
_BlobÂ v2 learns boundaries, bounces off walls, and gains a silky rayâ€‘marched surface._

---

## 0Â Â·Â What we add in this stage

| Module | Purpose |
|--------|---------|
| **`SdfCollisionSystem`** | Keeps every particle outside analytic shapes (planes, boxes, spheres). |
| **`JumpFloodSdfSystem`** | Builds a dynamic **signedâ€‘distance texture** of the blob each frame with the Jumpâ€‘Flooding Algorithm (JFA) so the mesh & collisions are 100Â % GPU. |
| **`RayMarchMaterial`** | Replaces MarchingCubes with a oneâ€‘pass rayâ€‘march shader â†’ smoother, cheaper. |
| **UI** | Leva folder â€œCollidersâ€ lets you toggle primitives and drag them around. |
| **Docs** | `milestoneâ€‘2â€‘sdf.mdx` explains SDF math + JFA passes, embedded demo. |

---

## 1Â Â·Â Analytic Collider Registry

Create **`packages/physics-sph/src/colliders.ts`**

```ts
export type Collider =
  | { kind: 'plane'; n: [number, number, number]; d: number }
  | { kind: 'sphere'; c: [number, number, number]; r: number }
  | { kind: 'box';    c: [number, number, number]; e: [number, number, number] };

export const colliders: Collider[] = [
  { kind: 'plane', n: [0, 1, 0], d: -0.02 },                 // floor
  { kind: 'box',   c: [0.2, 0.15, 0], e: [0.05, 0.05, 0.05]} // user box
];
```

Leva panel binds to `colliders[1].c` & `e` so you can slide position & size.

---

## 2Â Â·Â Collision response on CPU (quick baseline)

Add **`SdfCollisionSystem`**

```ts
import { Position, Velocity } from './components';
import { colliders } from './colliders';

function signedDistance(pos: Vec3): number {
  let d = -Infinity;
  for (const c of colliders) {
    if (c.kind === 'plane')
      d = max(d, dot(pos, c.n) + c.d);
    if (c.kind === 'sphere')
      d = max(d, length(sub(pos, c.c)) - c.r);
    if (c.kind === 'box')
      d = max(d, length(max(abs(sub(pos, c.c)) - c.e, 0)));
  }
  return d;
}

export class SdfCollisionSystem {
  execute(world: World) {
    for (const eid of world.query([Position, Velocity])) {
      const p: Vec3 = { x: Position.x[eid], y: Position.y[eid], z: Position.z[eid] };
      const dist = signedDistance(p);
      if (dist < 0.0) {                         // penetration
        // push particle out along gradient (finite diff 3â€‘sample)
        const eps = 0.001;
        const grad = {
          x: signedDistance(add(p, [eps,0,0])) - dist,
          y: signedDistance(add(p, [0,eps,0])) - dist,
          z: signedDistance(add(p, [0,0,eps])) - dist,
        };
        const gLen = length(grad) + 1e-6;
        Position.x[eid] += (-dist) * grad.x / gLen;
        Position.y[eid] += (-dist) * grad.y / gLen;
        Position.z[eid] += (-dist) * grad.z / gLen;
        // simple bounce
        Velocity.x[eid] *= 0.5;
        Velocity.y[eid] *= -0.3;
        Velocity.z[eid] *= 0.5;
      }
    }
  }
}
register(SdfCollisionSystem);
```

Good for â‰¤10Â k particles; weâ€™ll GPUâ€‘ify in a moment.

---

## 3Â Â·Â Realtime Jumpâ€‘Flood SDF (GPU)

### 3.1Â Add the dependency

```bash
pnpm add gpu-distance-field             # MIT lib that wraps JFAÂ îˆ€citeîˆ‚turn0search3îˆ
```

### 3.2Â Create **`JumpFloodSdfSystem`**

```ts
import { createSDFGenerator } from 'gpu-distance-field';
import { World } from '@blobverse/ecs-core';
import { Position } from './components';

export class JumpFloodSdfSystem {
  private sdf = createSDFGenerator({ width:512, height:512 });

  execute(world: World) {
    this.sdf.begin();                        // clear seeds
    for (const eid of world.query([Position])) {
      this.sdf.seed(Position.x[eid], Position.y[eid]); // drop pixel seed
    }
    this.sdf.compute();                      // 10â€“12Â JFA passes
    // result texture is this.sdf.texture â€“ feed to RayMarchMaterial & GPU collider
  }
}
```

The GPU library uses the textbook Rong & Tan JFAÂ îˆ€citeîˆ‚turn0search0îˆ; on most laptops 512Â² finishes <Â 1Â ms.

---

## 4Â Â·Â Rayâ€‘marched Surface Material

**`packages/vis-shaders/src/RayMarchMaterial.ts`**

```ts
import { ShaderMaterial } from 'three';
import sdRaymarchFrag from './shaders/raymarch.frag?raw';

export const RayMarchMaterial = (distTex: THREE.Texture) =>
  new ShaderMaterial({
    uniforms: {
      uDist: { value: distTex },
      uInvProj: { value: new THREE.Matrix4() },
      iso: { value: 0.0 }
    },
    vertexShader: /* glsl */`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position,1.);
      }
    `,
    fragmentShader: sdRaymarchFrag,
    transparent: true
  });
```

**`raymarch.frag`** (fragment):

```glsl
uniform sampler2D uDist;          // jumpâ€‘flood SDF
uniform mat4 uInvProj;
uniform float iso;                // usually 0

varying vec2 vUv;

float distField(vec3 p) {
  vec2 uv = p.xy * 0.5 + 0.5;
  return texture2D(uDist, uv).r + p.z;   // treat red channel as height
}

void main() {
  vec3 ro = vec3((vUv*2.-1.), 1.5);      // camera origin (billboard ray)
  vec3 rd = normalize(vec3(0,0,-1));

  float t = 0.0;
  for(int i=0;i<64;i++){
    vec3 p = ro + t * rd;
    float d = distField(p) - iso;
    if (d < 0.001) { break; }
    t += d;                               // sphereâ€‘tracing
    if (t>3.0) discard;
  }
  gl_FragColor = vec4(0.5,0.9,1.0,1.0);
}
```

Mount it in dashboard:

```tsx
const meshRef = useRef<THREE.Mesh>();
const { texture: sdfTex } = useJumpFloodSdf();  // hook provides texture

useEffect(() => {
  if (meshRef.current) meshRef.current.material = RayMarchMaterial(sdfTex);
}, [sdfTex]);

<mesh ref={meshRef}>
  <planeGeometry args={[1,1]} />
</mesh>
```

---

## 5Â Â·Â GPU Collider (optional step)

Once JFA is running, you can sample the distance texture directly in the **positionFragmentShader** (WebGL) or WGSL to reject penetrations â€” remove CPU gradient math.

```glsl
float sdf = texture2D(uDist, uv).r;
if (sdf < 0.0) {
  pos -= normalize(grad) * sdf;   // push out
  vel *= 0.5;
}
```

*(grad = finiteâ€‘difference on distance field.)*

---

## 6Â Â·Â Leva integration

Add a new folder:

```json
"colliders": {
  "planeHeight": { "value": 0.0, "min": -0.3, "max": 0.3, "step": 0.01 },
  "boxSize":     { "value": 0.05, "min": 0.02, "max": 0.1 },
  "boxY":        { "value": 0.15, "min": 0.0,  "max": 0.3 }
}
```

Updates `colliders[]` reactively via zustand subscription.

---

## 7Â Â·Â Docs & Storybook

* **Storybook**: new storyÂ `SdfCollision.stories.tsx` that spawns the plane + box and displays FPS.  
* **Docs**: `milestoneâ€‘2â€‘sdf.mdx` â€“ in two pages:

  1. _â€œDistanceâ€‘Field Basicsâ€_ (equations, references to Quilez Jumpâ€‘FloodÂ îˆ€citeîˆ‚turn0search0îˆ).  
  2. _â€œRayâ€‘march vs. Marchingâ€‘Cubesâ€_ (pros/cons, screenshots).

---

## 8Â Â·Â CI updates

Add a third preview artifact: **`webgl-raymarch`** bundle (mesh off).  
GitHubÂ Actions job:

```yaml
- name: Build rayâ€‘march
  run: pnpm vite build --mode raymarch --outDir dist-ray
  env: { VITE_RENDER_MODE: raymarch }
```

Deploy that to Vercel under `/ray`.

---

## 9Â Â·Â Testing Before Commit

* Fluid bounces off floor plane and adjustable box.  
* FPS >Â 30 with 2Â k particles & 512Â² JFA.  
* Rayâ€‘march quad shows crisp edge (no MarchingCubes artifacts).  
* Browsers without WebGPU still see WebGL path (distance as red channel).

---

## 10Â Â·Â Push & Celebrate

```bash
git add .
git commit -m "feat: JFA SDF collisions + rayâ€‘marched surface"
git push origin main
```

Preview URLs:

* `/mesh` â€“ old MarchingCubes
* `/ray`  â€“ new rayâ€‘march
* `/gpu`  â€“ WebGPU WGSL path

Drop whichever link you want verified.  
When this is green we march to **StageÂ 4Â â€“ MLSâ€‘MPM hotâ€‘swap** (solid goo, fracture, sand!).  

Give me the word (or any red stackâ€‘trace) and weâ€™ll keep Blobby evolving. ğŸ«§ğŸš€