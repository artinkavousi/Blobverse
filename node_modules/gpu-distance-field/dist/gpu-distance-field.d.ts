declare module "graphics" {
    export namespace Graphics {
        class Rect {
            x: number;
            y: number;
            width: number;
            height: number;
            constructor(x?: number, y?: number, width?: number, height?: number);
            set(x: number, y: number, width: number, height: number): void;
            equals(other: Rect): boolean;
        }
        class Color {
            redF: number;
            greenF: number;
            blueF: number;
            alphaF: number;
            constructor(redF: number, greenF: number, blueF: number, alphaF: number);
            static TRANSPARENT: Color;
        }
        enum BlendOperation {
            ZERO = 0,
            ONE = 1,
            SOURCE_COLOR = 2,
            TARGET_COLOR = 3,
            INVERSE_SOURCE_COLOR = 4,
            INVERSE_TARGET_COLOR = 5,
            SOURCE_ALPHA = 6,
            TARGET_ALPHA = 7,
            INVERSE_SOURCE_ALPHA = 8,
            INVERSE_TARGET_ALPHA = 9,
            CONSTANT = 10,
            INVERSE_CONSTANT = 11
        }
        enum Primitive {
            TRIANGLES = 0,
            TRIANGLE_STRIP = 1
        }
        abstract class Context {
            abstract addContextResetHandler(callback: () => void): void;
            abstract beginFrame(): void;
            abstract clear(color: Color): void;
            abstract createMaterial(format: VertexFormat, vertexSource: string, fragmentSource: string): Material;
            abstract createTexture(format: TextureFormat, width: number, height: number, pixels?: Uint8Array): Texture;
            abstract createRenderTarget(texture: Texture): RenderTarget;
            abstract createVertexBuffer(byteCount: number): VertexBuffer;
            abstract currentRenderTarget: RenderTarget | null;
            abstract draw(primitive: Primitive, material: Material, vertices: VertexBuffer): void;
            abstract endFrame(): void;
            abstract removeContextResetHandler(callback: () => void): void;
            abstract resize(widthInPixels: number, heightInPixels: number, widthInAppUnits: number, heightInAppUnits: number): void;
            abstract setRenderTarget(renderTarget: RenderTarget | null): void;
            abstract setViewport(x: number, y: number, width: number, height: number): void;
            abstract viewport: Rect;
            abstract widthInPixels: number;
            abstract heightInPixels: number;
            abstract renderTargetHeightInPixels: number;
            abstract renderTargetWidthInPixels: number;
            abstract setBlendState(source: BlendOperation, target: BlendOperation): void;
            setCopyBlendState(): void;
            setAddBlendState(): void;
            setPremultipliedBlendState(): void;
            setUnpremultipliedBlendState(): void;
        }
        interface Material {
            context: Context;
            format: VertexFormat;
            fragmentSource: string;
            vertexSource: string;
            setUniformBool(name: string, x: boolean): void;
            setUniformFloat(name: string, x: number): void;
            setUniformInt(name: string, x: number): void;
            setUniformVec2(name: string, x: number, y: number): void;
            setUniformVec3(name: string, x: number, y: number, z: number): void;
            setUniformVec4(name: string, x: number, y: number, z: number, w: number): void;
            setUniformMat3(name: string, m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): void;
            setUniformSampler(name: string, texture: Texture, index: number): void;
            free(): void;
        }
        enum AttributeType {
            FLOAT = 0,
            BYTE = 1
        }
        function attributeByteLength(type: AttributeType): 1 | 4;
        class Attribute {
            readonly name: string;
            readonly type: AttributeType;
            readonly count: number;
            readonly byteOffset: number;
            constructor(name: string, type: AttributeType, count: number, byteOffset: number);
        }
        class VertexFormat {
            private _attributes;
            private _stride;
            get attributes(): Attribute[];
            get stride(): number;
            add(name: string, type: AttributeType, count: number): VertexFormat;
        }
        abstract class VertexBuffer {
            abstract byteCount: number;
            abstract context: Context;
            abstract move(sourceByteOffset: number, targetByteOffset: number, byteCount: number): void;
            abstract upload(bytes: Uint8Array, byteOffset?: number): void;
            uploadFloat32Array(floats: Float32Array): void;
            uploadFloats(floats: number[]): void;
            abstract free(): void;
        }
        enum PixelFilter {
            NEAREST = 0,
            LINEAR = 1
        }
        enum PixelWrap {
            REPEAT = 0,
            CLAMP = 1
        }
        class TextureFormat {
            readonly minFilter: PixelFilter;
            readonly magFilter: PixelFilter;
            readonly wrap: PixelWrap;
            constructor(minFilter: PixelFilter, magFilter: PixelFilter, wrap: PixelWrap);
            static LINEAR_CLAMP: TextureFormat;
            static LINEAR_MIN_NEAREST_MAG_CLAMP: TextureFormat;
            static NEAREST_CLAMP: TextureFormat;
        }
        interface Texture {
            context: Context;
            format: TextureFormat;
            width: number;
            height: number;
            resize(width: number, height: number, pixels?: Uint8Array | HTMLCanvasElement): void;
            setFormat(format: TextureFormat): void;
            free(): void;
        }
        interface RenderTarget {
            context: Context;
            texture: Texture;
            setColor(texture: Texture): void;
            free(): void;
        }
    }
    export namespace WebGL {
        export class Context extends Graphics.Context {
            private _attributeCount;
            private _blendOperationMap;
            private _blendOperations;
            private _contextResetHandlers;
            private _currentClearColor;
            private _currentRenderTarget;
            private _defaultViewport;
            private _forceStateUpdate;
            private _generation;
            private _gl;
            private _height;
            private _oldBlendOperations;
            private _oldRenderTarget;
            private _oldViewport;
            private _width;
            get widthInPixels(): number;
            get heightInPixels(): number;
            constructor(canvas?: HTMLCanvasElement);
            private handleWebglContextRestored;
            testContextLoss(): void;
            get gl(): WebGLRenderingContext;
            get generation(): number;
            addContextResetHandler(callback: () => void): void;
            removeContextResetHandler(callback: () => void): void;
            get currentRenderTarget(): RenderTarget;
            beginFrame(): void;
            endFrame(): void;
            setBlendState(source: Graphics.BlendOperation, target: Graphics.BlendOperation): void;
            setViewport(x: number, y: number, width: number, height: number): void;
            get viewport(): Graphics.Rect;
            get renderTargetWidthInPixels(): number;
            get renderTargetHeightInPixels(): number;
            draw(primitive: Graphics.Primitive, material: Graphics.Material, vertices: Graphics.VertexBuffer): void;
            resize(widthInPixels: number, heightInPixels: number, widthInAppUnits: number, heightInAppUnits: number): void;
            clear(color: Graphics.Color): void;
            setRenderTarget(renderTarget: Graphics.RenderTarget | null): void;
            createMaterial(format: Graphics.VertexFormat, vertexSource: string, fragmentSource: string): Graphics.Material;
            createVertexBuffer(byteCount: number): Graphics.VertexBuffer;
            createTexture(format: Graphics.TextureFormat, width: number, height: number, pixels?: Uint8Array): Graphics.Texture;
            createRenderTarget(texture: Graphics.Texture): Graphics.RenderTarget;
            private ANGLE_instanced_arrays;
            private ANGLE_instanced_arrays_generation;
            getANGLE_instanced_arrays(): ANGLE_instanced_arrays;
            _updateRenderTargetAndViewport(): void;
            _updateBlendState(): void;
            _updateFormat(format: Graphics.VertexFormat): void;
            getWebGLInfo(): {
                renderer: string | null;
                vendor: string | null;
                version: string | null;
            };
            static from(context: Graphics.Context): Context;
            static _packBlendModes(source: Graphics.BlendOperation, target: Graphics.BlendOperation): number;
            static COPY_BLEND_OPERATIONS: number;
        }
        class Texture implements Graphics.Texture {
            private readonly _context;
            private _format;
            private _width;
            private _height;
            private _pixels;
            private _texture;
            private _generation;
            private _isFormatDirty;
            private _isContentDirty;
            constructor(_context: Context, _format: Graphics.TextureFormat, _width: number, _height: number, _pixels?: Uint8Array | HTMLCanvasElement | null, _texture?: WebGLTexture | null, _generation?: number, _isFormatDirty?: boolean, _isContentDirty?: boolean);
            get context(): Context;
            get format(): Graphics.TextureFormat;
            get width(): number;
            get height(): number;
            resize(width: number, height: number, pixels?: Uint8Array | HTMLCanvasElement | null): void;
            setFormat(format: Graphics.TextureFormat): void;
            get texture(): WebGLTexture;
            free(): void;
            static from(texture: Graphics.Texture): Texture;
        }
        class RenderTarget implements Graphics.RenderTarget {
            private _context;
            private _texture;
            private _framebuffer;
            private _generation;
            private _isDirty;
            private _viewport;
            constructor(_context: Context, _texture: Texture, _framebuffer?: WebGLFramebuffer | null, _generation?: number, _isDirty?: boolean, _viewport?: Graphics.Rect);
            get context(): Context;
            get texture(): Texture;
            get viewport(): Graphics.Rect;
            setColor(texture: Graphics.Texture): void;
            get framebuffer(): WebGLFramebuffer;
            free(): void;
            static from(renderTarget: Graphics.RenderTarget | null): RenderTarget | null;
        }
        export {};
    }
}
declare module "shaders" {
    export const GLSLX_SOURCE_V_COPY_POSITION = "precision highp float;precision highp int;attribute vec2 B;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);void main(){gl_Position=vec4(B,0,1.);}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);";
    export const GLSLX_SOURCE_F_PREP_FOR_JFA = "precision highp float;precision highp int;uniform sampler2D q;uniform vec2 h;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);bool r(float a,float b,float c){return clamp(a,b,c)==a;}vec4 A(in vec2 b){vec2 a=b;a=floor(a*8.);return vec4(floor(a.x/255.),mod(a.x,255.),floor(a.y/255.),mod(a.y,255.))/255.;}vec4 m(vec2 b){vec2 a=b.xy/h,c=vec2(a.x,1.-a.y);return texture2D(q,c);}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);bool C(vec2 a,vec4 e,out x g){vec2 c=a.xy-j,d=a.xy+j;vec4 i=m(c),k=m(d);vec2 b=e.r>.5?vec2(0.,.5):vec2(.5,1.);if(r(i.r,b.x,b.y)){g=x(c,i);return true;}else if(r(k.r,b.x,b.y)){g=x(d,k);return true;}return false;}bool D(vec2 a,vec4 e,out x g){vec2 c=a.xy-j.yx,d=a.xy+j.yx;vec4 i=m(c),k=m(d);vec2 b=e.r>.5?vec2(0.,.5):vec2(.5,1.);if(r(k.r,b.x,b.y)){g=x(d,k);return true;}else if(r(i.r,b.x,b.y)){g=x(c,i);return true;}return false;}void main(){vec4 b=m(gl_FragCoord.xy);if(abs(b.r-.5)<.1)gl_FragColor=A(gl_FragCoord.xy);else{vec2 c=vec2(8129.);x a;if(C(gl_FragCoord.xy,b,a)){float d=b.r,g=a.o.r,k=abs(.5-d)/abs(g-d);c=mix(gl_FragCoord.xy,a.p,k);}if(D(gl_FragCoord.xy,b,a)){float e=b.r,i=a.o.r,E=abs(.5-e)/abs(i-e);c.x=min(c.x,gl_FragCoord.x),c.y=mix(gl_FragCoord.y,a.p.y,E);}gl_FragColor=A(c);}}";
    export const GLSLX_SOURCE_F_JUMP_FLOOD_OUTPUT_SEED_POSITION = "precision highp float;precision highp int;uniform sampler2D n;uniform vec2 h;uniform int y;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);vec2 l(in vec4 a){a*=255.;return vec2(a.x*255.+a.y,a.z*255.+a.w)/8.;}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);vec4 f(in vec4 a,in vec2 c){vec2 d=(gl_FragCoord.xy+c)/h;vec4 b=texture2D(n,d);vec2 e=l(a),g=l(b);float i=distance(e,gl_FragCoord.xy),k=distance(g,gl_FragCoord.xy);return i>k?b:a;}vec4 z(in vec4 a,in int b){a=f(a,vec2(0,b)),a=f(a,vec2(b,b)),a=f(a,vec2(b,0)),a=f(a,vec2(b,-b)),a=f(a,vec2(0,-b)),a=f(a,vec2(-b,-b)),a=f(a,vec2(-b,0)),a=f(a,vec2(-b,b));return a;}void main(){vec2 a=gl_FragCoord.xy/h;vec4 b=texture2D(n,a);gl_FragColor=z(b,y);}";
    export const GLSLX_SOURCE_F_JUMP_FLOOD_OUTPUT_DISTANCE = "precision highp float;precision highp int;uniform sampler2D q,n;uniform vec2 h;uniform int y;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);vec2 l(in vec4 a){a*=255.;return vec2(a.x*255.+a.y,a.z*255.+a.w)/8.;}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);vec4 f(in vec4 a,in vec2 c){vec2 d=(gl_FragCoord.xy+c)/h;vec4 b=texture2D(n,d);vec2 e=l(a),g=l(b);float i=distance(e,gl_FragCoord.xy),k=distance(g,gl_FragCoord.xy);return i>k?b:a;}vec4 z(in vec4 a,in int b){a=f(a,vec2(0,b)),a=f(a,vec2(b,b)),a=f(a,vec2(b,0)),a=f(a,vec2(b,-b)),a=f(a,vec2(0,-b)),a=f(a,vec2(-b,-b)),a=f(a,vec2(-b,0)),a=f(a,vec2(-b,b));return a;}vec4 F(in float a){a*=1000.,a+=8290687.5;return vec4(mod(floor(a/65025.),255.),mod(floor(a/255.),255.),mod(floor(a),255.),255.)/255.;}void main(){vec2 a=gl_FragCoord.xy/h;vec4 b=texture2D(n,a);b=z(b,y);vec4 c=texture2D(q,vec2(a.x,1.-a.y));vec2 d=l(b);float e=distance(d,gl_FragCoord.xy),g=c.r<.5?-1.:1.;gl_FragColor=F(g*e);}";
    export const GLSLX_NAME_U_RESOLUTION = "h";
    export const GLSLX_NAME_U_INPUT_TEXTURE = "n";
    export const GLSLX_NAME_U_SEED_INPUT_TEXTURE = "q";
    export const GLSLX_NAME_U_STEP_SIZE = "y";
    export const GLSLX_NAME_A_QUAD = "B";
}
declare module "gpu-distance-field" {
    type JumpFloodQuality = "JFA" | "JFA+1" | "JFA+2";
    type Options = {
        outputCanvas?: HTMLCanvasElement;
        sizeHint?: [number, number];
    };
    export class DistanceFieldGenerator {
        private _gl;
        private _outputCanvas;
        private _prepJumpFloodData;
        private _jumpFloodOutputSeedPosition;
        private _jumpFloodOutputDistance;
        private _quadBuffer;
        private _sourceTexture;
        private _destTexture;
        private _sourceTextureTarget;
        private _destTextureTarget;
        private _seedInputTexture;
        constructor(options?: Options);
        destroy(): void;
        outputCanvas(): HTMLCanvasElement;
        private _resizeTextureIfNecessary;
        private _resizeOutputCanvasAndTextures;
        generateSDF(inputCanvas: HTMLCanvasElement, quality?: JumpFloodQuality): void;
        getPixels(): Uint8Array;
        private _setSeedsFromCanvas;
        private _runJumpFloodStep;
        private _swapBuffers;
    }
}
