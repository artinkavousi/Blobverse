(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['gpu-distance-field'] = {}));
}(this, (function (exports) { 'use strict';

    // This file was originally written in Skew by my wonderful coworker Evan for
    function assert(condition) {
        {
            if (!condition)
                throw new Error("Assertion failed.");
        }
    }
    function appendOne(ts, t) {
        if (ts.indexOf(t) === -1)
            ts.push(t);
    }
    function removeOne(ts, t) {
        const index = ts.indexOf(t);
        if (index !== -1)
            ts.splice(index, 1);
    }
    function TEXTURE_N(gl, index) {
        assert(index >= 0 && index <= 31);
        return (gl.TEXTURE0 + index);
    }
    var Graphics;
    (function (Graphics) {
        class Rect {
            constructor(x = 0, y = 0, width = 0, height = 0) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            set(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            equals(other) {
                return (this.x === other.x &&
                    this.y === other.y &&
                    this.width === other.width &&
                    this.height === other.height);
            }
        }
        Graphics.Rect = Rect;
        class Color {
            constructor(redF, greenF, blueF, alphaF) {
                this.redF = redF;
                this.greenF = greenF;
                this.blueF = blueF;
                this.alphaF = alphaF;
            }
        }
        Color.TRANSPARENT = new Color(0, 0, 0, 0);
        Graphics.Color = Color;
        // Converted from https://github.com/evanw/sky/blob/c72de77/src/graphics/context.sk
        let BlendOperation;
        (function (BlendOperation) {
            BlendOperation[BlendOperation["ZERO"] = 0] = "ZERO";
            BlendOperation[BlendOperation["ONE"] = 1] = "ONE";
            BlendOperation[BlendOperation["SOURCE_COLOR"] = 2] = "SOURCE_COLOR";
            BlendOperation[BlendOperation["TARGET_COLOR"] = 3] = "TARGET_COLOR";
            BlendOperation[BlendOperation["INVERSE_SOURCE_COLOR"] = 4] = "INVERSE_SOURCE_COLOR";
            BlendOperation[BlendOperation["INVERSE_TARGET_COLOR"] = 5] = "INVERSE_TARGET_COLOR";
            BlendOperation[BlendOperation["SOURCE_ALPHA"] = 6] = "SOURCE_ALPHA";
            BlendOperation[BlendOperation["TARGET_ALPHA"] = 7] = "TARGET_ALPHA";
            BlendOperation[BlendOperation["INVERSE_SOURCE_ALPHA"] = 8] = "INVERSE_SOURCE_ALPHA";
            BlendOperation[BlendOperation["INVERSE_TARGET_ALPHA"] = 9] = "INVERSE_TARGET_ALPHA";
            BlendOperation[BlendOperation["CONSTANT"] = 10] = "CONSTANT";
            BlendOperation[BlendOperation["INVERSE_CONSTANT"] = 11] = "INVERSE_CONSTANT";
        })(BlendOperation = Graphics.BlendOperation || (Graphics.BlendOperation = {}));
        let Primitive;
        (function (Primitive) {
            Primitive[Primitive["TRIANGLES"] = 0] = "TRIANGLES";
            Primitive[Primitive["TRIANGLE_STRIP"] = 1] = "TRIANGLE_STRIP";
        })(Primitive = Graphics.Primitive || (Graphics.Primitive = {}));
        class Context {
            setCopyBlendState() {
                this.setBlendState(BlendOperation.ONE, BlendOperation.ZERO);
            }
            setAddBlendState() {
                this.setBlendState(BlendOperation.ONE, BlendOperation.ONE);
            }
            setPremultipliedBlendState() {
                this.setBlendState(BlendOperation.ONE, BlendOperation.INVERSE_SOURCE_ALPHA);
            }
            setUnpremultipliedBlendState() {
                this.setBlendState(BlendOperation.SOURCE_ALPHA, BlendOperation.INVERSE_SOURCE_ALPHA);
            }
        }
        Graphics.Context = Context;
        let AttributeType;
        (function (AttributeType) {
            AttributeType[AttributeType["FLOAT"] = 0] = "FLOAT";
            AttributeType[AttributeType["BYTE"] = 1] = "BYTE";
        })(AttributeType = Graphics.AttributeType || (Graphics.AttributeType = {}));
        function attributeByteLength(type) {
            return type == AttributeType.FLOAT ? 4 : 1;
        }
        Graphics.attributeByteLength = attributeByteLength;
        class Attribute {
            constructor(name, type, count, byteOffset) {
                this.name = name;
                this.type = type;
                this.count = count;
                this.byteOffset = byteOffset;
            }
        }
        Graphics.Attribute = Attribute;
        class VertexFormat {
            constructor() {
                this._attributes = [];
                this._stride = 0;
            }
            get attributes() {
                return this._attributes;
            }
            get stride() {
                return this._stride;
            }
            add(name, type, count) {
                this.attributes.push(new Attribute(name, type, count, this.stride));
                this._stride += count * attributeByteLength(type);
                return this;
            }
        }
        Graphics.VertexFormat = VertexFormat;
        class VertexBuffer {
            uploadFloat32Array(floats) {
                this.upload(new Uint8Array(floats.buffer), 0);
            }
            uploadFloats(floats) {
                this.uploadFloat32Array(new Float32Array(floats));
            }
        }
        Graphics.VertexBuffer = VertexBuffer;
        let PixelFilter;
        (function (PixelFilter) {
            PixelFilter[PixelFilter["NEAREST"] = 0] = "NEAREST";
            PixelFilter[PixelFilter["LINEAR"] = 1] = "LINEAR";
        })(PixelFilter = Graphics.PixelFilter || (Graphics.PixelFilter = {}));
        let PixelWrap;
        (function (PixelWrap) {
            PixelWrap[PixelWrap["REPEAT"] = 0] = "REPEAT";
            PixelWrap[PixelWrap["CLAMP"] = 1] = "CLAMP";
        })(PixelWrap = Graphics.PixelWrap || (Graphics.PixelWrap = {}));
        class TextureFormat {
            constructor(minFilter, magFilter, wrap) {
                this.minFilter = minFilter;
                this.magFilter = magFilter;
                this.wrap = wrap;
            }
        }
        TextureFormat.LINEAR_CLAMP = new TextureFormat(PixelFilter.LINEAR, PixelFilter.LINEAR, PixelWrap.CLAMP);
        TextureFormat.LINEAR_MIN_NEAREST_MAG_CLAMP = new TextureFormat(PixelFilter.LINEAR, PixelFilter.NEAREST, PixelWrap.CLAMP);
        TextureFormat.NEAREST_CLAMP = new TextureFormat(PixelFilter.NEAREST, PixelFilter.NEAREST, PixelWrap.CLAMP);
        Graphics.TextureFormat = TextureFormat;
    })(Graphics || (Graphics = {}));
    // Converted from https://github.com/evanw/sky/blob/c72de77/src/browser/context.sk
    var WebGL;
    (function (WebGL) {
        class Context extends Graphics.Context {
            constructor(canvas = document.createElement("canvas")) {
                super();
                this._attributeCount = 0;
                this._blendOperations = 0;
                this._contextResetHandlers = [];
                this._currentClearColor = Graphics.Color.TRANSPARENT;
                this._currentRenderTarget = null;
                this._defaultViewport = new Graphics.Rect();
                this._forceStateUpdate = true;
                this._generation = 1;
                this._height = 0;
                this._oldBlendOperations = 0;
                this._oldRenderTarget = null;
                this._oldViewport = new Graphics.Rect();
                this._width = 0;
                this.handleWebglContextRestored = () => {
                    this._attributeCount = 0;
                    this._currentClearColor = Graphics.Color.TRANSPARENT;
                    this._forceStateUpdate = true;
                    this._generation++;
                    for (let handler of this._contextResetHandlers) {
                        handler();
                    }
                };
                this.ANGLE_instanced_arrays = null;
                this.ANGLE_instanced_arrays_generation = -1;
                let gl = canvas.getContext("webgl", {
                    alpha: false,
                    antialias: false,
                    depth: false,
                    preserveDrawingBuffer: true,
                    stencil: false,
                });
                if (gl == null) {
                    throw new Error("Setup failure");
                }
                this._gl = gl;
                let style = canvas.style;
                canvas.width = 0;
                canvas.height = 0;
                style.width = style.height = "0";
                canvas.addEventListener("webglcontextlost", (e) => {
                    e.preventDefault();
                });
                canvas.addEventListener("webglcontextrestored", this.handleWebglContextRestored);
                // Using maps makes these compact in release
                this._blendOperationMap = {
                    [Graphics.BlendOperation.ZERO]: this._gl.ZERO,
                    [Graphics.BlendOperation.ONE]: this._gl.ONE,
                    [Graphics.BlendOperation.SOURCE_COLOR]: this._gl.SRC_COLOR,
                    [Graphics.BlendOperation.TARGET_COLOR]: this._gl.DST_COLOR,
                    [Graphics.BlendOperation.INVERSE_SOURCE_COLOR]: this._gl
                        .ONE_MINUS_SRC_COLOR,
                    [Graphics.BlendOperation.INVERSE_TARGET_COLOR]: this._gl
                        .ONE_MINUS_DST_COLOR,
                    [Graphics.BlendOperation.SOURCE_ALPHA]: this._gl.SRC_ALPHA,
                    [Graphics.BlendOperation.TARGET_ALPHA]: this._gl.DST_ALPHA,
                    [Graphics.BlendOperation.INVERSE_SOURCE_ALPHA]: this._gl
                        .ONE_MINUS_SRC_ALPHA,
                    [Graphics.BlendOperation.INVERSE_TARGET_ALPHA]: this._gl
                        .ONE_MINUS_DST_ALPHA,
                    [Graphics.BlendOperation.CONSTANT]: this._gl.CONSTANT_COLOR,
                    [Graphics.BlendOperation.INVERSE_CONSTANT]: this._gl
                        .ONE_MINUS_CONSTANT_COLOR,
                };
            }
            get widthInPixels() {
                return this._width;
            }
            get heightInPixels() {
                return this._height;
            }
            testContextLoss() {
                this.handleWebglContextRestored();
            }
            get gl() {
                return this._gl;
            }
            get generation() {
                return this._generation;
            }
            addContextResetHandler(callback) {
                appendOne(this._contextResetHandlers, callback);
            }
            removeContextResetHandler(callback) {
                removeOne(this._contextResetHandlers, callback);
            }
            get currentRenderTarget() {
                return this._currentRenderTarget;
            }
            beginFrame() {
                this.setRenderTarget(null);
            }
            endFrame() { }
            setBlendState(source, target) {
                this._blendOperations = Context._packBlendModes(source, target);
            }
            setViewport(x, y, width, height) {
                (this._currentRenderTarget != null
                    ? this._currentRenderTarget.viewport
                    : this._defaultViewport).set(x, y, width, height);
            }
            get viewport() {
                return this._currentRenderTarget != null
                    ? this._currentRenderTarget.viewport
                    : this._defaultViewport;
            }
            get renderTargetWidthInPixels() {
                return this._currentRenderTarget != null
                    ? this._currentRenderTarget.viewport.width
                    : this._width;
            }
            get renderTargetHeightInPixels() {
                return this._currentRenderTarget != null
                    ? this._currentRenderTarget.viewport.height
                    : this._height;
            }
            draw(primitive, material, vertices) {
                // Update the texture set before preparing the material so uniform samplers can check for that they use different textures
                this._updateRenderTargetAndViewport();
                Material.from(material).prepare();
                // Update the vertex buffer before updating the format so attributes can bind correctly
                VertexBuffer.from(vertices).prepare();
                this._updateFormat(material.format);
                // Draw now that everything is ready
                this._updateBlendState();
                this._gl.drawArrays(primitive == Graphics.Primitive.TRIANGLES
                    ? this._gl.TRIANGLES
                    : this._gl.TRIANGLE_STRIP, 0, Math.floor(vertices.byteCount / material.format.stride));
                // Forced state updates are done once after a context loss
                this._forceStateUpdate = false;
            }
            resize(widthInPixels, heightInPixels, widthInAppUnits, heightInAppUnits) {
                let canvas = this._gl.canvas;
                const bounds = canvas.getBoundingClientRect();
                if (this._width === widthInAppUnits &&
                    this._height === heightInPixels &&
                    bounds.width === widthInAppUnits &&
                    bounds.height === heightInAppUnits) {
                    // Nothing to do here!
                    return;
                }
                let style = canvas.style;
                canvas.width = widthInPixels;
                canvas.height = heightInPixels;
                style.width = `${widthInAppUnits}px`;
                style.height = `${heightInAppUnits}px`;
                this.setViewport(0, 0, widthInPixels, heightInPixels);
                this._width = widthInPixels;
                this._height = heightInPixels;
            }
            clear(color) {
                this._updateRenderTargetAndViewport();
                this._updateBlendState();
                if (color != this._currentClearColor) {
                    this._gl.clearColor(color.redF, color.greenF, color.blueF, color.alphaF);
                    this._currentClearColor = color;
                }
                this._gl.clear(this._gl.COLOR_BUFFER_BIT);
            }
            setRenderTarget(renderTarget) {
                this._currentRenderTarget = RenderTarget.from(renderTarget);
            }
            createMaterial(format, vertexSource, fragmentSource) {
                let material = new Material(this, format, vertexSource, fragmentSource);
                return material;
            }
            createVertexBuffer(byteCount) {
                assert(byteCount > 0 && byteCount % 4 == 0);
                return new VertexBuffer(this, byteCount);
            }
            createTexture(format, width, height, pixels) {
                return new Texture(this, format, width, height, pixels);
            }
            createRenderTarget(texture) {
                return new RenderTarget(this, Texture.from(texture));
            }
            getANGLE_instanced_arrays() {
                if (this.ANGLE_instanced_arrays_generation !== this._generation) {
                    this.ANGLE_instanced_arrays = null;
                }
                if (!this.ANGLE_instanced_arrays) {
                    this.ANGLE_instanced_arrays = this.gl.getExtension("ANGLE_instanced_arrays");
                    if (!this.ANGLE_instanced_arrays) {
                        throw new Error("Failed to get extension ANGLE_instanced_arrays");
                    }
                }
                return this.ANGLE_instanced_arrays;
            }
            _updateRenderTargetAndViewport() {
                let renderTarget = this._currentRenderTarget;
                let viewport = renderTarget != null ? renderTarget.viewport : this._defaultViewport;
                let gl = this._gl;
                if (this._forceStateUpdate || this._oldRenderTarget != renderTarget) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget ? renderTarget.framebuffer : null);
                    this._oldRenderTarget = renderTarget;
                }
                if (this._forceStateUpdate || !this._oldViewport.equals(viewport)) {
                    gl.viewport(viewport.x, this.renderTargetHeightInPixels - viewport.y - viewport.height, viewport.width, viewport.height);
                    this._oldViewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                }
            }
            _updateBlendState() {
                if (this._forceStateUpdate ||
                    this._oldBlendOperations != this._blendOperations) {
                    let gl = this._gl;
                    let operations = this._blendOperations;
                    let oldOperations = this._oldBlendOperations;
                    let source = (operations & 0xf);
                    let target = (operations >> 4);
                    assert(source in this._blendOperationMap);
                    assert(target in this._blendOperationMap);
                    // Special-case the blend mode that just writes over the target buffer
                    if (operations == Context.COPY_BLEND_OPERATIONS) {
                        gl.disable(gl.BLEND);
                    }
                    else {
                        if (this._forceStateUpdate ||
                            oldOperations == Context.COPY_BLEND_OPERATIONS) {
                            gl.enable(gl.BLEND);
                        }
                        // Otherwise, use actual blending
                        gl.blendFunc(this._blendOperationMap[source], this._blendOperationMap[target]);
                    }
                    this._oldBlendOperations = operations;
                }
            }
            _updateFormat(format) {
                // Update the attributes
                let gl = this._gl;
                let attributes = format.attributes;
                let count = attributes.length;
                for (let i = 0; i < count; i++) {
                    let attribute = attributes[i];
                    let isByte = attribute.type == Graphics.AttributeType.BYTE;
                    gl.vertexAttribPointer(i, attribute.count, isByte ? gl.UNSIGNED_BYTE : gl.FLOAT, isByte, format.stride, attribute.byteOffset);
                }
                // Update the attribute count
                while (this._attributeCount < count) {
                    gl.enableVertexAttribArray(this._attributeCount);
                    this._attributeCount++;
                }
                while (this._attributeCount > count) {
                    this._attributeCount--;
                    gl.disableVertexAttribArray(this._attributeCount);
                }
                this._attributeCount = count;
            }
            getWebGLInfo() {
                const ext = this.gl.getExtension("WEBGL_debug_renderer_info");
                const renderer = ext
                    ? this.gl.getParameter(ext.UNMASKED_RENDERER_WEBGL)
                    : null;
                const vendor = ext
                    ? this.gl.getParameter(ext.UNMASKED_VENDOR_WEBGL)
                    : null;
                const version = this.gl.getParameter(this.gl.VERSION);
                return { renderer, vendor, version };
            }
            static from(context) {
                assert(context == null || context instanceof Context);
                return context;
            }
            static _packBlendModes(source, target) {
                return source | (target << 4);
            }
        }
        Context.COPY_BLEND_OPERATIONS = Context._packBlendModes(Graphics.BlendOperation.ONE, Graphics.BlendOperation.ZERO);
        WebGL.Context = Context;
        class Uniform {
            constructor(_material, _name, _generation = 0, _location = null, _isDirty = true) {
                this._material = _material;
                this._name = _name;
                this._generation = _generation;
                this._location = _location;
                this._isDirty = _isDirty;
            }
            get location() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation) {
                    this._location = context.gl.getUniformLocation(this._material.program, this._name);
                    this._generation = context.generation;
                    // Validate the shader against this uniform
                    {
                        let program = this._material.program;
                        let gl = context.gl;
                        for (let i = 0, ii = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); i < ii; i++) {
                            let info = gl.getActiveUniform(program, i);
                            if (info && info.name == this._name) {
                                assert(info.size == 1);
                                switch (info.type) {
                                    case gl.FLOAT: {
                                        assert(this instanceof UniformFloat);
                                        break;
                                    }
                                    case gl.BOOL: {
                                        assert(this instanceof UniformBool);
                                        break;
                                    }
                                    case gl.FLOAT_MAT3: {
                                        assert(this instanceof UniformMat3);
                                        break;
                                    }
                                    case gl.FLOAT_VEC2: {
                                        assert(this instanceof UniformVec2);
                                        break;
                                    }
                                    case gl.FLOAT_VEC3: {
                                        assert(this instanceof UniformVec3);
                                        break;
                                    }
                                    case gl.FLOAT_VEC4: {
                                        assert(this instanceof UniformVec4);
                                        break;
                                    }
                                    case gl.INT: {
                                        assert(this instanceof UniformInt);
                                        break;
                                    }
                                    case gl.SAMPLER_2D: {
                                        assert(this instanceof UniformSampler);
                                        break;
                                    }
                                    default:
                                        assert(false);
                                }
                            }
                        }
                    }
                }
                if (!this._location) {
                    throw new Error("Failed to get uniform location");
                }
                return this._location;
            }
        }
        class UniformFloat extends Uniform {
            constructor() {
                super(...arguments);
                this._x = 0.0;
            }
            set(x) {
                if (x != this._x) {
                    this._x = x;
                    this._isDirty = true;
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation || this._isDirty) {
                    context.gl.uniform1f(this.location, this._x);
                    this._isDirty = false;
                }
            }
        }
        class UniformBool extends Uniform {
            constructor() {
                super(...arguments);
                this._x = false;
            }
            set(x) {
                if (x != this._x) {
                    this._x = x;
                    this._isDirty = true;
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation || this._isDirty) {
                    context.gl.uniform1i(this.location, this._x ? 1 : 0);
                    this._isDirty = false;
                }
            }
        }
        class UniformInt extends Uniform {
            constructor() {
                super(...arguments);
                this._x = 0;
            }
            set(x) {
                if (x != this._x) {
                    this._x = x;
                    this._isDirty = true;
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation || this._isDirty) {
                    context.gl.uniform1i(this.location, this._x);
                    this._isDirty = false;
                }
            }
        }
        class UniformVec2 extends Uniform {
            constructor() {
                super(...arguments);
                this._x = 0.0;
                this._y = 0.0;
            }
            set(x, y) {
                if (x != this._x || y != this._y) {
                    this._x = x;
                    this._y = y;
                    this._isDirty = true;
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation || this._isDirty) {
                    context.gl.uniform2f(this.location, this._x, this._y);
                    this._isDirty = false;
                }
            }
        }
        class UniformVec3 extends Uniform {
            constructor() {
                super(...arguments);
                this._x = 0.0;
                this._y = 0.0;
                this._z = 0.0;
            }
            set(x, y, z) {
                if (x != this._x || y != this._y || z != this._z) {
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    this._isDirty = true;
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation || this._isDirty) {
                    context.gl.uniform3f(this.location, this._x, this._y, this._z);
                    this._isDirty = false;
                }
            }
        }
        class UniformVec4 extends Uniform {
            constructor() {
                super(...arguments);
                this._x = 0.0;
                this._y = 0.0;
                this._z = 0.0;
                this._w = 0.0;
            }
            set(x, y, z, w) {
                if (x != this._x || y != this._y || z != this._z || w != this._w) {
                    this._x = x;
                    this._y = y;
                    this._z = z;
                    this._w = w;
                    this._isDirty = true;
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation || this._isDirty) {
                    context.gl.uniform4f(this.location, this._x, this._y, this._z, this._w);
                    this._isDirty = false;
                }
            }
        }
        class UniformMat3 extends Uniform {
            constructor() {
                super(...arguments);
                this._values = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
            }
            set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                // These values are deliberately transposed because WebGL requires the "transpose" argument of uniformMatrix() to be false
                UniformMat3._cachedValues[0] = m00;
                UniformMat3._cachedValues[1] = m10;
                UniformMat3._cachedValues[2] = m20;
                UniformMat3._cachedValues[3] = m01;
                UniformMat3._cachedValues[4] = m11;
                UniformMat3._cachedValues[5] = m21;
                UniformMat3._cachedValues[6] = m02;
                UniformMat3._cachedValues[7] = m12;
                UniformMat3._cachedValues[8] = m22;
                for (let i = 0; i < 9; i++) {
                    if (UniformMat3._cachedValues[i] != this._values[i]) {
                        let swap = this._values;
                        this._values = UniformMat3._cachedValues;
                        UniformMat3._cachedValues = swap;
                        this._isDirty = true;
                        break;
                    }
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                if (this._generation != context.generation || this._isDirty) {
                    context.gl.uniformMatrix3fv(this.location, false, this._values);
                    this._isDirty = false;
                }
            }
        }
        // Statically allocate this to avoid allocations
        UniformMat3._cachedValues = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];
        class UniformSampler extends Uniform {
            constructor() {
                super(...arguments);
                this._texture = null;
                this._index = -1;
            }
            set(texture, index) {
                if (this._texture != texture || this._index != index) {
                    this._texture = Texture.from(texture);
                    this._index = index;
                    this._isDirty = true;
                }
            }
            prepare() {
                let context = Context.from(this._material.context);
                let gl = context.gl;
                assert(this._texture == null ||
                    context.currentRenderTarget == null ||
                    this._texture != context.currentRenderTarget.texture);
                if (this._generation != context.generation || this._isDirty) {
                    gl.uniform1i(this.location, this._index);
                    this._isDirty = false;
                }
                gl.activeTexture(TEXTURE_N(gl, this._index));
                gl.bindTexture(gl.TEXTURE_2D, this._texture != null &&
                    this._texture.width > 0 &&
                    this._texture.height > 0
                    ? this._texture.texture
                    : null);
            }
        }
        class Material {
            constructor(_context, _format, _vertexSource, _fragmentSource, _uniformsMap = {}, _uniformsList = [], _generation = 0, _program = null) {
                this._context = _context;
                this._format = _format;
                this._vertexSource = _vertexSource;
                this._fragmentSource = _fragmentSource;
                this._uniformsMap = _uniformsMap;
                this._uniformsList = _uniformsList;
                this._generation = _generation;
                this._program = _program;
            }
            get context() {
                return this._context;
            }
            get format() {
                return this._format;
            }
            get vertexSource() {
                return this._vertexSource;
            }
            get fragmentSource() {
                return this._fragmentSource;
            }
            free() {
                if (this._program) {
                    this._context.gl.deleteProgram(this._program);
                }
                // Reset the generation to force this to be re-uploaded if it's used again
                // in the future.
                this._generation = 0;
            }
            setUniformBool(name, x) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformBool(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformBool);
                uniform.set(x);
            }
            setUniformFloat(name, x) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformFloat(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformFloat);
                uniform.set(x);
            }
            setUniformInt(name, x) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformInt(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformInt);
                uniform.set(x);
            }
            setUniformVec2(name, x, y) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformVec2(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformVec2);
                uniform.set(x, y);
            }
            setUniformVec3(name, x, y, z) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformVec3(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformVec3);
                uniform.set(x, y, z);
            }
            setUniformVec4(name, x, y, z, w) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformVec4(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformVec4);
                uniform.set(x, y, z, w);
            }
            setUniformMat3(name, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformMat3(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformMat3);
                uniform.set(m00, m01, m02, m10, m11, m12, m20, m21, m22);
            }
            setUniformSampler(name, texture, index) {
                let uniform = this._uniformsMap[name] || null;
                if (uniform == null) {
                    uniform = new UniformSampler(this, name);
                    this._uniformsMap[name] = uniform;
                    this._uniformsList.push(uniform);
                }
                assert(uniform instanceof UniformSampler);
                uniform.set(texture, index);
            }
            get program() {
                let gl = this._context.gl;
                if (this._generation != this._context.generation) {
                    this._program = gl.createProgram();
                    this._compileShader(gl, gl.VERTEX_SHADER, this.vertexSource);
                    this._compileShader(gl, gl.FRAGMENT_SHADER, this.fragmentSource);
                    let attributes = this.format.attributes;
                    for (let i = 0; i < attributes.length; i++) {
                        gl.bindAttribLocation(this._program, i, attributes[i].name);
                    }
                    gl.linkProgram(this._program);
                    if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
                        throw new Error(`${gl.getProgramInfoLog(this._program)}`);
                    }
                    this._generation = this._context.generation;
                    // Validate this shader against the format
                    {
                        for (let attribute of attributes) {
                            for (let i = 0, ii = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES); i < ii; i++) {
                                let info = gl.getActiveAttrib(this.program, i);
                                if (info && info.name == attribute.name) {
                                    assert(info.size == 1);
                                    switch (attribute.count) {
                                        case 1: {
                                            assert(info.type == gl.FLOAT);
                                            break;
                                        }
                                        case 2: {
                                            assert(info.type == gl.FLOAT_VEC2);
                                            break;
                                        }
                                        case 3: {
                                            assert(info.type == gl.FLOAT_VEC3);
                                            break;
                                        }
                                        case 4: {
                                            assert(info.type == gl.FLOAT_VEC4);
                                            break;
                                        }
                                        default: {
                                            assert(false);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return this._program;
            }
            prepare() {
                this._context.gl.useProgram(this.program);
                for (let uniform of this._uniformsList) {
                    uniform.prepare();
                }
            }
            _compileShader(gl, type, source) {
                let shader = gl.createShader(type);
                if (!shader) {
                    throw new Error("Failed to create shader");
                }
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error(`${gl.getShaderInfoLog(shader)}`);
                }
                if (!this._program) {
                    throw new Error("Tried to attach shader before program was created");
                }
                gl.attachShader(this._program, shader);
            }
            static from(material) {
                assert(material == null || material instanceof Material);
                return material;
            }
        }
        class VertexBuffer extends Graphics.VertexBuffer {
            constructor(context, byteCount) {
                super();
                this._generation = 0;
                this._buffer = null;
                this._bytes = null;
                this._isDirty = true;
                this._dirtyMin = VertexBuffer.INT_MAX;
                this._dirtyMax = 0;
                this._totalMin = VertexBuffer.INT_MAX;
                this._totalMax = 0;
                this._byteCount = 0;
                this._context = context;
                this._byteCount = byteCount;
                this._bytes = new Uint8Array(byteCount);
            }
            get context() {
                return this._context;
            }
            get byteCount() {
                return this._byteCount;
            }
            move(sourceByteOffset, targetByteOffset, byteCount) {
                assert(byteCount >= 0);
                assert(0 <= sourceByteOffset && sourceByteOffset + byteCount <= this._byteCount);
                assert(0 <= targetByteOffset && targetByteOffset + byteCount <= this._byteCount);
                if (this._bytes &&
                    sourceByteOffset != targetByteOffset &&
                    byteCount != 0) {
                    this._bytes.set(this._bytes.subarray(sourceByteOffset, this._byteCount), targetByteOffset);
                    this._growDirtyRegion(Math.min(sourceByteOffset, targetByteOffset), Math.max(sourceByteOffset, targetByteOffset) + byteCount);
                }
            }
            upload(bytes, byteOffset = 0) {
                assert(0 <= byteOffset && byteOffset + bytes.length <= this._byteCount);
                assert(this._bytes != null);
                this._bytes.set(bytes, byteOffset);
                this._growDirtyRegion(byteOffset, byteOffset + bytes.length);
            }
            free() {
                if (this._buffer) {
                    this._context.gl.deleteBuffer(this._buffer);
                }
                // Reset the generation to force this to be re-uploaded if it's used again
                // in the future.
                this._generation = 0;
            }
            prepare() {
                let gl = this._context.gl;
                if (this._generation !== this._context.generation) {
                    this._buffer = gl.createBuffer();
                    this._generation = this._context.generation;
                    this._isDirty = true;
                }
                gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
                if (this._isDirty) {
                    gl.bufferData(gl.ARRAY_BUFFER, this._byteCount, gl.DYNAMIC_DRAW);
                    this._dirtyMin = this._totalMin;
                    this._dirtyMax = this._totalMax;
                    this._isDirty = false;
                }
                if (this._dirtyMin < this._dirtyMax) {
                    gl.bufferSubData(gl.ARRAY_BUFFER, this._dirtyMin, this._bytes.subarray(this._dirtyMin, this._dirtyMax));
                    this._dirtyMin = VertexBuffer.INT_MAX;
                    this._dirtyMax = 0;
                }
            }
            _growDirtyRegion(min, max) {
                this._dirtyMin = Math.min(this._dirtyMin, min);
                this._dirtyMax = Math.max(this._dirtyMax, max);
                this._totalMin = Math.min(this._totalMin, min);
                this._totalMax = Math.max(this._totalMax, max);
            }
            static from(buffer) {
                assert(buffer == null || buffer instanceof VertexBuffer);
                return buffer;
            }
        }
        VertexBuffer.INT_MAX = 0x7fffffff;
        class Texture {
            constructor(_context, _format, _width, _height, _pixels = null, _texture = null, _generation = 0, _isFormatDirty = true, _isContentDirty = true) {
                this._context = _context;
                this._format = _format;
                this._width = _width;
                this._height = _height;
                this._pixels = _pixels;
                this._texture = _texture;
                this._generation = _generation;
                this._isFormatDirty = _isFormatDirty;
                this._isContentDirty = _isContentDirty;
            }
            get context() {
                return this._context;
            }
            get format() {
                return this._format;
            }
            get width() {
                return this._width;
            }
            get height() {
                return this._height;
            }
            resize(width, height, pixels = null) {
                this._width = width;
                this._height = height;
                this._pixels = pixels;
                this._isContentDirty = true;
            }
            setFormat(format) {
                if (this._format != format) {
                    this._format = format;
                    this._isFormatDirty = true;
                }
            }
            get texture() {
                let gl = this._context.gl;
                // Create
                if (this._generation != this._context.generation) {
                    this._texture = gl.createTexture();
                    this._generation = this._context.generation;
                    this._isFormatDirty = true;
                    this._isContentDirty = true;
                }
                // Format
                if (this._isFormatDirty) {
                    gl.bindTexture(gl.TEXTURE_2D, this._texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.format.magFilter == Graphics.PixelFilter.NEAREST
                        ? gl.NEAREST
                        : gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.format.minFilter == Graphics.PixelFilter.NEAREST
                        ? gl.NEAREST
                        : gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.format.wrap == Graphics.PixelWrap.REPEAT
                        ? gl.REPEAT
                        : gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.format.wrap == Graphics.PixelWrap.REPEAT
                        ? gl.REPEAT
                        : gl.CLAMP_TO_EDGE);
                    this._isFormatDirty = false;
                }
                if (this._isContentDirty) {
                    gl.bindTexture(gl.TEXTURE_2D, this._texture);
                    if (this._pixels instanceof HTMLCanvasElement) {
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._pixels);
                    }
                    else {
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._width, this._height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this._pixels);
                    }
                    this._isContentDirty = false;
                }
                return this._texture;
            }
            free() {
                if (this.texture) {
                    this._context.gl.deleteTexture(this.texture);
                    this._generation = 0;
                }
            }
            static from(texture) {
                assert(texture == null || texture instanceof Texture);
                return texture;
            }
        }
        class RenderTarget {
            constructor(_context, _texture, _framebuffer = null, _generation = 0, _isDirty = true, _viewport = new Graphics.Rect()) {
                this._context = _context;
                this._texture = _texture;
                this._framebuffer = _framebuffer;
                this._generation = _generation;
                this._isDirty = _isDirty;
                this._viewport = _viewport;
            }
            get context() {
                return this._context;
            }
            get texture() {
                return this._texture;
            }
            get viewport() {
                return this._viewport;
            }
            setColor(texture) {
                if (this._texture != texture) {
                    this._texture = Texture.from(texture);
                    this._isDirty = true;
                }
            }
            get framebuffer() {
                let gl = this._context.gl;
                let texture = this._texture.texture;
                // Create
                if (this._generation != this._context.generation) {
                    this._framebuffer = gl.createFramebuffer();
                    this._generation = this._context.generation;
                    this._isDirty = true;
                }
                // Update
                if (this._isDirty) {
                    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                    assert(gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);
                    this._isDirty = false;
                }
                return this._framebuffer;
            }
            free() {
                if (this._framebuffer) {
                    this._context.gl.deleteFramebuffer(this._framebuffer);
                    this._generation = 0;
                }
            }
            static from(renderTarget) {
                assert(renderTarget == null || renderTarget instanceof RenderTarget);
                return renderTarget;
            }
        }
    })(WebGL || (WebGL = {}));

    const GLSLX_SOURCE_V_COPY_POSITION = "precision highp float;precision highp int;attribute vec2 B;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);void main(){gl_Position=vec4(B,0,1.);}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);";
    const GLSLX_SOURCE_F_PREP_FOR_JFA = "precision highp float;precision highp int;uniform sampler2D q;uniform vec2 h;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);bool r(float a,float b,float c){return clamp(a,b,c)==a;}vec4 A(in vec2 b){vec2 a=b;a=floor(a*8.);return vec4(floor(a.x/255.),mod(a.x,255.),floor(a.y/255.),mod(a.y,255.))/255.;}vec4 m(vec2 b){vec2 a=b.xy/h,c=vec2(a.x,1.-a.y);return texture2D(q,c);}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);bool C(vec2 a,vec4 e,out x g){vec2 c=a.xy-j,d=a.xy+j;vec4 i=m(c),k=m(d);vec2 b=e.r>.5?vec2(0.,.5):vec2(.5,1.);if(r(i.r,b.x,b.y)){g=x(c,i);return true;}else if(r(k.r,b.x,b.y)){g=x(d,k);return true;}return false;}bool D(vec2 a,vec4 e,out x g){vec2 c=a.xy-j.yx,d=a.xy+j.yx;vec4 i=m(c),k=m(d);vec2 b=e.r>.5?vec2(0.,.5):vec2(.5,1.);if(r(k.r,b.x,b.y)){g=x(d,k);return true;}else if(r(i.r,b.x,b.y)){g=x(c,i);return true;}return false;}void main(){vec4 b=m(gl_FragCoord.xy);if(abs(b.r-.5)<.1)gl_FragColor=A(gl_FragCoord.xy);else{vec2 c=vec2(8129.);x a;if(C(gl_FragCoord.xy,b,a)){float d=b.r,g=a.o.r,k=abs(.5-d)/abs(g-d);c=mix(gl_FragCoord.xy,a.p,k);}if(D(gl_FragCoord.xy,b,a)){float e=b.r,i=a.o.r,E=abs(.5-e)/abs(i-e);c.x=min(c.x,gl_FragCoord.x),c.y=mix(gl_FragCoord.y,a.p.y,E);}gl_FragColor=A(c);}}";
    const GLSLX_SOURCE_F_JUMP_FLOOD_OUTPUT_SEED_POSITION = "precision highp float;precision highp int;uniform sampler2D n;uniform vec2 h;uniform int y;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);vec2 l(in vec4 a){a*=255.;return vec2(a.x*255.+a.y,a.z*255.+a.w)/8.;}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);vec4 f(in vec4 a,in vec2 c){vec2 d=(gl_FragCoord.xy+c)/h;vec4 b=texture2D(n,d);vec2 e=l(a),g=l(b);float i=distance(e,gl_FragCoord.xy),k=distance(g,gl_FragCoord.xy);return i>k?b:a;}vec4 z(in vec4 a,in int b){a=f(a,vec2(0,b)),a=f(a,vec2(b,b)),a=f(a,vec2(b,0)),a=f(a,vec2(b,-b)),a=f(a,vec2(0,-b)),a=f(a,vec2(-b,-b)),a=f(a,vec2(-b,0)),a=f(a,vec2(-b,b));return a;}void main(){vec2 a=gl_FragCoord.xy/h;vec4 b=texture2D(n,a);gl_FragColor=z(b,y);}";
    const GLSLX_SOURCE_F_JUMP_FLOOD_OUTPUT_DISTANCE = "precision highp float;precision highp int;uniform sampler2D q,n;uniform vec2 h;uniform int y;const vec4 s=vec4(1.,0.,0.,1.),t=vec4(0.,1.,0.,1.),u=vec4(0.,0.,1.,1.),v=vec4(0.,0.,0.,1.),w=vec4(1.,1.,1.,1.);vec2 l(in vec4 a){a*=255.;return vec2(a.x*255.+a.y,a.z*255.+a.w)/8.;}struct x{vec2 p;vec4 o;};const vec2 j=vec2(1.,0.);vec4 f(in vec4 a,in vec2 c){vec2 d=(gl_FragCoord.xy+c)/h;vec4 b=texture2D(n,d);vec2 e=l(a),g=l(b);float i=distance(e,gl_FragCoord.xy),k=distance(g,gl_FragCoord.xy);return i>k?b:a;}vec4 z(in vec4 a,in int b){a=f(a,vec2(0,b)),a=f(a,vec2(b,b)),a=f(a,vec2(b,0)),a=f(a,vec2(b,-b)),a=f(a,vec2(0,-b)),a=f(a,vec2(-b,-b)),a=f(a,vec2(-b,0)),a=f(a,vec2(-b,b));return a;}vec4 F(in float a){a*=1000.,a+=8290687.5;return vec4(mod(floor(a/65025.),255.),mod(floor(a/255.),255.),mod(floor(a),255.),255.)/255.;}void main(){vec2 a=gl_FragCoord.xy/h;vec4 b=texture2D(n,a);b=z(b,y);vec4 c=texture2D(q,vec2(a.x,1.-a.y));vec2 d=l(b);float e=distance(d,gl_FragCoord.xy),g=c.r<.5?-1.:1.;gl_FragColor=F(g*e);}";
    const GLSLX_NAME_U_RESOLUTION = "h";
    const GLSLX_NAME_U_INPUT_TEXTURE = "n";
    const GLSLX_NAME_U_SEED_INPUT_TEXTURE = "q";
    const GLSLX_NAME_U_STEP_SIZE = "y";
    const GLSLX_NAME_A_QUAD = "B";

    class DistanceFieldGenerator {
        constructor(options = {}) {
            // WebGL doesn't let you write to the texture you're reading from.
            // So we ping-pong data back and forth between these two textures.
            this._sourceTexture = null;
            this._destTexture = null;
            this._sourceTextureTarget = null;
            this._destTextureTarget = null;
            this._seedInputTexture = null;
            if (options.outputCanvas != null) {
                this._outputCanvas = options.outputCanvas;
            }
            else {
                this._outputCanvas = document.createElement("canvas");
            }
            const sizeHint = options.outputCanvas != null
                ? [options.outputCanvas.width, options.outputCanvas.height]
                : options.sizeHint != null
                    ? options.sizeHint
                    : [100, 100];
            this._gl = new WebGL.Context(this._outputCanvas);
            this._resizeOutputCanvasAndTextures(sizeHint[0], sizeHint[1], "force-update");
            const gl = this._gl;
            // Disable all blending
            this._gl.setCopyBlendState();
            const vertexFormat = new Graphics.VertexFormat();
            vertexFormat.add(GLSLX_NAME_A_QUAD, Graphics.AttributeType.FLOAT, 2);
            // Create programs
            this._prepJumpFloodData = gl.createMaterial(vertexFormat, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_PREP_FOR_JFA);
            this._jumpFloodOutputSeedPosition = gl.createMaterial(vertexFormat, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_JUMP_FLOOD_OUTPUT_SEED_POSITION);
            this._jumpFloodOutputDistance = gl.createMaterial(vertexFormat, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_JUMP_FLOOD_OUTPUT_DISTANCE);
            // All draw calls use a single quad
            const QUAD = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            this._quadBuffer = gl.createVertexBuffer(vertexFormat.stride * QUAD.length);
            this._quadBuffer.upload(new Uint8Array(QUAD.buffer));
        }
        destroy() {
            // Delete WebGL resources. These would eventually be garbage collected, but this
            // can take a while as explained here: https://stackoverflow.com/a/58505477
            if (this._sourceTexture) {
                this._sourceTexture.free();
            }
            if (this._destTexture) {
                this._destTexture.free();
            }
            if (this._seedInputTexture) {
                this._seedInputTexture.free();
            }
            // Delete buffers
            this._quadBuffer.free();
            // Delete programs
            this._prepJumpFloodData.free();
            this._jumpFloodOutputDistance.free();
            this._jumpFloodOutputSeedPosition.free();
        }
        outputCanvas() {
            return this._outputCanvas;
        }
        _resizeTextureIfNecessary(texture, newWidth, newHeight, forceUpdate = "dont-force") {
            if (texture.width === newWidth &&
                texture.height === newHeight &&
                forceUpdate !== "force-update") {
                return;
            }
            texture.resize(newWidth, newHeight);
        }
        _resizeOutputCanvasAndTextures(newWidth, newHeight, forceUpdate = "dont-force") {
            const gl = this._gl;
            const outputCanvas = this._outputCanvas;
            const outputCanvasSizeNeedsUpdate = outputCanvas.width !== newWidth ||
                outputCanvas.height !== newHeight ||
                forceUpdate === "force-update";
            if (outputCanvasSizeNeedsUpdate) {
                gl.resize(newWidth, newHeight, newWidth, newHeight);
            }
            // Resize or create textures if necessary
            if (this._sourceTexture == null) {
                this._sourceTexture = gl.createTexture(Graphics.TextureFormat.NEAREST_CLAMP, newWidth, newHeight);
                this._sourceTextureTarget = gl.createRenderTarget(this._sourceTexture);
            }
            else {
                this._resizeTextureIfNecessary(this._sourceTexture, newWidth, newHeight);
            }
            if (this._destTexture == null) {
                this._destTexture = gl.createTexture(Graphics.TextureFormat.NEAREST_CLAMP, newWidth, newHeight);
                this._destTextureTarget = gl.createRenderTarget(this._destTexture);
            }
            else {
                this._resizeTextureIfNecessary(this._destTexture, newWidth, newHeight);
            }
            if (this._seedInputTexture == null) {
                this._seedInputTexture = gl.createTexture(Graphics.TextureFormat.NEAREST_CLAMP, newWidth, newHeight);
            }
            else {
                this._resizeTextureIfNecessary(this._seedInputTexture, newWidth, newHeight);
            }
        }
        // Generates an SDF for antialiased black shapes drawn on a
        // white canvas (e.g. drawn by the Canvas2D API).
        generateSDF(inputCanvas, quality = "JFA") {
            const width = inputCanvas.width;
            const height = inputCanvas.height;
            this._resizeOutputCanvasAndTextures(width, height);
            this._setSeedsFromCanvas(inputCanvas);
            const maxDimension = Math.max(width, height);
            let stepSize = nextPowerOfTwo(maxDimension) / 2;
            while (stepSize >= 1) {
                const isLastStep = stepSize / 2 < 1 && quality == "JFA";
                const output = isLastStep
                    ? JumpFloodOutput.FOR_SCREEN
                    : JumpFloodOutput.FOR_ANOTHER_STEP;
                this._runJumpFloodStep(stepSize, output);
                stepSize /= 2;
            }
            switch (quality) {
                case "JFA": {
                    // We're done
                    break;
                }
                case "JFA+1": {
                    // Run the last step again
                    this._runJumpFloodStep(1, JumpFloodOutput.FOR_SCREEN);
                    break;
                }
                case "JFA+2": {
                    // Run the last two steps again
                    this._runJumpFloodStep(4, JumpFloodOutput.FOR_ANOTHER_STEP);
                    this._runJumpFloodStep(3, JumpFloodOutput.FOR_ANOTHER_STEP);
                    this._runJumpFloodStep(2, JumpFloodOutput.FOR_ANOTHER_STEP);
                    this._runJumpFloodStep(1, JumpFloodOutput.FOR_SCREEN);
                    break;
                }
            }
        }
        getPixels() {
            const gl = this._gl.gl;
            const pixels = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
            gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            return pixels;
        }
        // Move seed data from _seedInputTexture into _sourceTexture so that it
        // can be used for our jump flood algorithm.
        //
        // We could build this into the first step of the algorithm but it's
        // cleaner as a separate step and when I attempted to remove it it only
        // gave a 2fps improvement on large canvasses.
        _setSeedsFromCanvas(inputCanvas) {
            if (!this._seedInputTexture) {
                throw new Error(`Expected _seedInputTexture to be set before calling setSeedsFromCanvas`);
            }
            const width = inputCanvas.width;
            const height = inputCanvas.height;
            this._seedInputTexture.resize(width, height, inputCanvas);
            const material = this._prepJumpFloodData;
            material.setUniformSampler(GLSLX_NAME_U_SEED_INPUT_TEXTURE, this._seedInputTexture, 0);
            material.setUniformVec2(GLSLX_NAME_U_RESOLUTION, width, height);
            this._gl.setRenderTarget(this._sourceTextureTarget);
            this._gl.setViewport(0, 0, width, height);
            this._gl.draw(Graphics.Primitive.TRIANGLE_STRIP, material, this._quadBuffer);
        }
        // Run an iteration of the jump flood algorithm, using the suggested
        // output format.
        //
        // The current simulation state is always in _sourceTexture
        // and we draw onto _destTexture.
        _runJumpFloodStep(stepSize, output) {
            if (!this._sourceTexture || !this._seedInputTexture) {
                throw new Error(`Expected textures to be set before calling setSeedsFromCanvas`);
            }
            const { width, height } = this._outputCanvas;
            const material = output.format === "seed-position"
                ? this._jumpFloodOutputSeedPosition
                : this._jumpFloodOutputDistance;
            material.setUniformSampler(GLSLX_NAME_U_INPUT_TEXTURE, this._sourceTexture, 0);
            material.setUniformInt(GLSLX_NAME_U_STEP_SIZE, stepSize);
            material.setUniformVec2(GLSLX_NAME_U_RESOLUTION, width, height);
            if (output.format === "distance") {
                material.setUniformSampler(GLSLX_NAME_U_SEED_INPUT_TEXTURE, this._seedInputTexture, 1);
            }
            this._gl.setRenderTarget(output.renderTarget === "texture" ? this._destTextureTarget : null);
            this._gl.setViewport(0, 0, width, height);
            this._gl.draw(Graphics.Primitive.TRIANGLE_STRIP, material, this._quadBuffer);
            this._swapBuffers();
        }
        _swapBuffers() {
            const tmp = this._sourceTexture;
            const tmpTarget = this._sourceTextureTarget;
            this._sourceTexture = this._destTexture;
            this._sourceTextureTarget = this._destTextureTarget;
            this._destTexture = tmp;
            this._destTextureTarget = tmpTarget;
        }
    }
    function nextPowerOfTwo(n) {
        n--;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        n++;
        return n;
    }
    var JumpFloodOutput;
    (function (JumpFloodOutput) {
        JumpFloodOutput.FOR_ANOTHER_STEP = {
            format: "seed-position",
            renderTarget: "texture",
        };
        JumpFloodOutput.FOR_SCREEN = {
            format: "distance",
            renderTarget: "screen",
        };
    })(JumpFloodOutput || (JumpFloodOutput = {}));

    exports.DistanceFieldGenerator = DistanceFieldGenerator;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
