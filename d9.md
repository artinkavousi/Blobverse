ğŸ«§ **StageÂ 5Â â€“Â Reactionâ€‘Diffusion Skin** ğŸ«§  
_Blob becomes a living canvas: dynamic chemical patterns ripple across its surface in real time._

---

## 0Â Â·Â Goals of StageÂ 5

1. **Integrate a GPUâ€‘based Reactionâ€‘Diffusion (RD) system** (Grayâ€‘Scott or similar) as a â€œchemical fieldâ€ layer.  
2. **Advection coupling**: RD chemicals advect with the fluid velocity (SPH) or grid velocity (MPM).  
3. **Visual mapping**: Drive surface color or emissive intensity from RD concentrations.  
4. **UI**: Leva controls for RD rates (`feed`, `kill`, `diffA`, `diffB`), coupling strength, and color palettes.  
5. **Docs & Demos**: MDX tutorial â€œFrom Equations to Spots,â€ Storybook â€œRdSkinDemo.â€

---

## 1Â Â·Â RD GPU Module (`field-rd` package)

```
packages/field-rd/
â”œâ”€ src/
â”‚  â”œâ”€ components.ts          â† no ECS components needed
â”‚  â”œâ”€ RdSystem.ts            â† CPU wrapper scheduling two shaders
â”‚  â””â”€ gpu/
â”‚     â”œâ”€ rd-init.frag        â† seeds texture A=1, B=0 (+ optional spots)
â”‚     â”œâ”€ rd-update.frag      â† Grayâ€‘Scott update (pingâ€‘pong)
â”‚     â””â”€ rd-advect.frag      â† advect A,B via velocity field
â””â”€ metadata.json             â† Leva presets for RD rates
```

### 1.1Â `rd-init.frag`

```glsl
precision highp float;
varying vec2 vUv;
void main(){
  // A=1 everywhere, B=0
  float A = 1.0; 
  float B = (length(vUv - 0.5)<0.05) ? 1.0 : 0.0;
  gl_FragColor = vec4(A, B, 0.0, 1.0);
}
```

### 1.2Â `rd-update.frag` (Grayâ€‘Scott)

```glsl
precision highp float;
uniform sampler2D texAB;    // RG: A,B
uniform float feed, kill, diffA, diffB, dt;
varying vec2 vUv;

float laplacianA(){
  vec2 off = vec2(1.)/resolution.xy;
  float sum = 0.0;
  sum += texture2D(texAB, vUv + vec2(-off.x,0)).r;
  sum += texture2D(texAB, vUv + vec2(off.x,0)).r;
  sum += texture2D(texAB, vUv + vec2(0,-off.y)).r;
  sum += texture2D(texAB, vUv + vec2(0,off.y)).r;
  sum -= 4.0 * texture2D(texAB, vUv).r;
  return sum;
}

void main(){
  vec2 ab = texture2D(texAB, vUv).rg;
  float A = ab.r, B = ab.g;
  float lapA = laplacianA();
  float lapB = /* same for B */;
  // Grayâ€‘Scott equations
  float dA = diffA * lapA - A*B*B + feed*(1.0 - A);
  float dB = diffB * lapB + A*B*B - (kill + feed)*B;
  A += dA * dt;
  B += dB * dt;
  gl_FragColor = vec4(A, B, 0.0, 1.0);
}
```

### 1.3Â `RdSystem.ts`

```ts
import { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js';
import { register } from '@blobverse/ecs-core';
import updateFrag from './gpu/rd-update.frag?raw';
import advectFrag from './gpu/rd-advect.frag?raw';
import initFrag   from './gpu/rd-init.frag?raw';
import meta from './metadata.json';

export class RdSystem {
  private gpu: GPUComputationRenderer;
  private texAB0: any;
  private varUpdate: any;
  private varAdvect: any;

  constructor(renderer: WebGLRenderer, width = 256) {
    this.gpu = new GPUComputationRenderer(width, width, renderer);
    this.texAB0 = this.gpu.createTexture();
    this.gpu.renderTexture(initFrag, this.texAB0);  
    const texAB1 = this.gpu.createTexture();
    this.varUpdate = this.gpu.addVariable('texAB', updateFrag, this.texAB0);
    this.varAdvect = this.gpu.addVariable('texAB', advectFrag, texAB1);
    this.gpu.setVariableDependencies(this.varUpdate, [this.varUpdate]);
    this.gpu.setVariableDependencies(this.varAdvect, [this.varUpdate]);
    this.gpu.init();
  }

  execute(renderer: WebGLRenderer) {
    const { feed, kill, diffA, diffB, dt } = meta.controls;
    this.varUpdate.material.uniforms = { feed, kill, diffA, diffB, dt };
    this.gpu.compute();
    // swap pingâ€‘pong
    const obj = this.varUpdate; this.varUpdate = this.varAdvect; this.varAdvect = obj;
  }
}
register(RdSystem);
```

---

## 2Â Â·Â Advecting with Velocity

- **SPH path:** Read `texturePosition` & `textureVelocity` from `physics-sph`â€™s GPUComputationRenderer, sample those in `rd-advect.frag` to move chemical â€œparticlesâ€ around.
- **MPM path:** Sample grid velocities from MPMâ€™s compute pipeline, same idea.

---

## 3Â Â·Â Skinning the Surface

### 3.1Â Points renderer

```tsx
// in Particles.tsx
import rdTex from '@blobverse/field-rd/texAB?raw'; // last computation

<Points â€¦>
  <shaderMaterial
    uniforms={{ rdTex: { value: rdTex }, palette: { value: [vec3(...), ...] } }}
    vertexShader={/* passthrough */} 
    fragmentShader={/* sample rdTex, map B channel to color */}
  />
</Points>
```

### 3.2Â RayMarch mesh

Add uniforms `uRD` and inside `raymarch.frag`:

```glsl
float B = texture2D(uRD, uv).g;
vec3 col = mix(vec3(0.2,0.7,1.0), vec3(1.0,0.2,0.3), B);
gl_FragColor = vec4(col,1.0);
```

---

## 4Â Â·Â UI Controls (`field-rd/metadata.json`)

```json
{
  "displayName": "Reactionâ€‘Diffusion",
  "controls": {
    "feed":  { "value": 0.037, "min": 0.0,  "max": 0.1,   "step": 0.001 },
    "kill":  { "value": 0.06,  "min": 0.0,  "max": 0.1,   "step": 0.001 },
    "diffA": { "value": 1.0,   "min": 0.1,  "max": 2.0,   "step": 0.1 },
    "diffB": { "value": 0.5,   "min": 0.1,  "max": 2.0,   "step": 0.1 },
    "dt":    { "value": 1.0,   "min": 0.01, "max": 2.0,   "step": 0.01 }
  }
}
```

---

## 5Â Â·Â Docs & Storybook

- **Storybook**: `RdSkinDemo.stories.tsx`â€”live knobs for feed/kill, shows canvas.  
- **Docs**: `milestoneâ€‘4â€‘rd.mdx`â€”walk through diffusion equation, GIF of evolving spots, embed interactive demo via Sandpack or iframe.

---

## 6Â Â·Â Performance & Testing

- **Compute**: RD update + advect => ~0.5Â ms @Â 256Â².  
- **Visuals**: Points + material sampling ~ 10Â k particles at 60Â FPS.  
- **Correctness**: Patterns transition from spots to stripes as feed/kill vary.

---

## 7Â Â·Â Commit & Deploy

```bash
git add packages/field-rd apps/dashboard-app
git commit -m "feat: reaction-diffusion skin + advected patterns"
git push origin main
```

CI will publish a `/rd` preview URL. Paste that here to confirm you see dynamic patterns crawling over Blobbyâ€™s shapeshifting form. ğŸ«§âœ¨