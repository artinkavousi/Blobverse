ğŸ«§ **StageÂ 2 â€“ Real GPU FluidÂ (â€œSPHâ€‘GPU Alphaâ€)** ğŸ«§  
_in which Blobby stops pretending with CPU maths and moves densityÂ +Â pressure to the GPU, then shows a gooey metaball surface instead of dots._

---

## 0Â Â·Â Roadâ€‘map snapshot  

| Stage | Scope (doneÂ âœ“ / nextÂ âŸ²) |
|-------|--------------------------|
| 1 | CPU integrator, ECS, pointâ€‘rendererÂ âœ“ |
| 2 | **GPU densityÂ +Â pressure + metaball mesh**Â âŸ² |
| 3 | Jumpâ€‘Flood SDF collisions |
| 4 | WebGPU MLSâ€‘MPM swapâ€‘in |
| 5 | Reactionâ€‘Diffusion surface skin |

---

## 1Â Â·Â GPU Density & Pressure Pass (WebGL path)

### 1.1Â Add a **`density.frag`** shader

```
packages/physics-sph/src/gpu/shaders/density.frag
```

```glsl
#include <common>  // brings in PI, etc.

uniform sampler2D texturePosition;
uniform float h;          // smoothing radius
uniform float restDensity;

void main() {
  vec2 uv  = gl_FragCoord.xy / resolution.xy;
  vec3 pos = texture2D(texturePosition, uv).xyz;

  float rho = 0.0;
  // 9â€‘tap neighbourhood (cheap substitute for hash grid on GPU):
  for (int dx=-1; dx<=1; dx++)
    for (int dy=-1; dy<=1; dy++) {
      vec2 off = vec2(dx,dy) / resolution.xy;
      vec3 q   = texture2D(texturePosition, uv + off).xyz;
      float r  = length(pos - q);
      if (r < h) {
        float coeff = 315. * pow(h*h - r*r, 3.0) / (64.*PI*pow(h,9.));
        rho += coeff;
      }
    }
  gl_FragColor = vec4(rho, 0.0,0.0,1.0);
}
```

### 1.2Â Add a **`pressure.frag`**

```glsl
uniform sampler2D textureDensity;
uniform float k;
uniform float restDensity;

void main() {
  float rho = texture2D(textureDensity, gl_FragCoord.xy/resolution.xy).r;
  float P   = k * (rho - restDensity);
  gl_FragColor = vec4(P,0,0,1);
}
```

### 1.3Â Register in `SphCompute.ts`

```ts
const denVar = gpuCompute.addVariable('textureDensity',  denFrag, texDensity0);
const preVar = gpuCompute.addVariable('texturePressure', pressureFrag, texPressure0);
gpuCompute.setVariableDependencies(denVar, [posVar]);
gpuCompute.setVariableDependencies(preVar, [posVar, denVar]);
```

Now each `compute()` call generates density & pressure textures you can read in **`positionFragmentShader`** to apply forces (replace the naÃ¯ve gravity lines with pressureâ€‘viscosity forces using texture lookâ€‘ups).

---

## 2Â Â·Â WebGPU counterpart (WGSL)

Add functions inside `sph.wgsl`:

```wgsl
fn poly6(r: f32, h: f32) -> f32 {
  return select(0.0,
    315.0 / (64.0 * PI * h*h*h*h*h*h*h*h*h) * pow(h*h - r*r, 3.0),
    r <= h);
}

fn spiky_grad(r: f32, h: f32) -> f32 {
  return select(0.0,
    -45.0 / (PI * pow(h,6.0)) * pow(h - r, 2.0),
    r > 0.0 && r <= h);
}
```

Add a **second compute pipeline** (`densityPipeline`) that first iterates particles and writes density to a storage buffer; a **third pipeline** (`forcePipeline`) reads densityÂ +Â pressure and updates velocity/pos.

The helper `registerComputePipeline()` in `ecs-core` can accept *workgroup size*, *WGSL source*, and *bind group layout*; schedule them in order each frame.

---

## 3Â Â·Â Metaball Surface Mesh

### 3.1Â Quick hack: Three.js `MarchingCubes`

```tsx
import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js';

const mc = new MarchingCubes(32, new THREE.MeshStandardMaterial({
  color: '#7fd7ff',
  metalness: 0.1,
  roughness: 0.25,
}), true, true);

mc.position.set(0, 0.15, 0);
mc.scale.set(0.5, 0.5, 0.5);
scene.add(mc);

useFrame(() => {
  mc.reset();
  for (const eid of world.query([Position])) {
    mc.addBall(Position.x[eid], Position.y[eid], Position.z[eid], 0.05, 12);
  }
});
```

*That loop is CPU â†’ MarchingCubes, acceptable for a couple thousand particles.*  
In StageÂ 3 weâ€™ll replace with **GPU SDF â†’ rayâ€‘march** or **isosurface via Jumpâ€‘Flood**.

---

## 4Â Â·Â Leva + Zustand wiring

Add new uniforms `k` and `h` in the Leva metadata; inside `SphCompute.ts` update the uniforms on `gpuCompute` variables each frame:

```ts
posVar.material.uniforms.h.value    = store.getState().h;
denVar.material.uniforms.h.value    = store.getState().h;
preVar.material.uniforms.k.value    = store.getState().k;
```

Zustandâ€™s `subscribe` lets you reactively patch uniforms when sliders move.

---

## 5Â Â·Â Docs & Storybook

* **Storybook**: update `SphDemo.stories.tsx` to mount the MarchingCubes scene and knobs for `nParticles`.  
* **Docs**: extend `milestoneâ€‘1â€‘sph.mdx` with equations for polyâ€‘6, spikyâ€‘grad, screenshots, and an iframe demo pointing to the Storybook URL.

---

## 6Â Â·Â Testing checklist before commit

1. **Dev FPSÂ â‰¥Â 30** with 2Â k particles.  
2. Turning `h` or `k` in Leva changes blob squishiness in real time.  
3. MarchingCubes mesh updates every frame without gaps.  
4. WebGPU code path runs in Chromium Canary behind `--enable-dawn-features=allow_unsafe_apis`, falls back to WebGL automatically.

When all green:

```bash
git add .
git commit -m "feat: GPU density+pressure pass & metaball renderer"
git push origin main
```

CI builds *four* bundles:

| Target | Renderer | Compute path |
|--------|----------|--------------|
| `webgl-points` | ThreeÂ WebGL | GPUComputationRenderer |
| `webgl-mesh`   | ThreeÂ WebGL | GPURenderer + MarchingCubes |
| `webgpu-points`| R3F WebGPU | WGSL compute + Points |
| `webgpu-mesh`  | R3F WebGPU | WGSL compute + mesh |

Preview URLs appear in the PR comment. Paste them here and weâ€™ll polish performance & start collision SDFs (StageÂ 3).  

Blobbyâ€™s now *properly liquid*â€”time to splash around! ğŸ«§ğŸŒŠ