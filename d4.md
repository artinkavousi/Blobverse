### BoomÂ ğŸ’¥â€”the SPH code compiles, Vite is serving onÂ `localhost:5178`, and youâ€™ve got a live Leva panel.  
Time to **light the GPU thrusters** and render an actual blob onâ€‘screen. Below is a readyâ€‘toâ€‘paste bundle of the next items on our milestone list:

| âœ”ï¸Â Task | Files / commands you add **now** |
|---------|-----------------------------------|
| **1.Â Wire particle rendering** (CPU â†’ GPU) | `apps/dashboard-app/src/Particles.tsx` (R3F `<Points>`); import in `App.tsx`. |
| **2.Â GPUComputationRenderer pass** (WebGL fallback) | `packages/physics-sph/src/gpu/SphCompute.ts` + tiny helper in core. |
| **3.Â WebGPU compute shaders** (WGSL) | `packages/physics-sph/src/gpu/sph.wgsl` + runtime registration. |
| **4.Â Autoâ€‘Leva metadata** | `packages/physics-sph/metadata.json` (controls forÂ `h`,Â `mu`,Â `restDensity`â€¦). |
| **5.Â Storybook + Docs** stubs | Story `SphDemo.stories.tsx`; docs `docs/milestoneâ€‘1â€‘sph.mdx`. |

Everything is **dropâ€‘in**â€”no refactorsâ€”so you can commit each chunk and immediately see particles sloshing.

---

## 1Â Â·Â `Particles.tsx` â€“ drawÂ N instanced spheres/points

```tsx
// apps/dashboard-app/src/Particles.tsx
import { useFrame } from '@react-three/fiber';
import { Points, PointMaterial } from '@react-three/drei';
import { World } from '@blobverse/ecs-core';
import { Position } from '@blobverse/physics-sph';

export function Particles({ world, max = 5_000 }) {
  const positions = new Float32Array(max * 3);

  useFrame(() => {
    let i = 0;
    for (const eid of (world.query ?? [])([Position])) {
      positions[i++] = Position.x[eid];
      positions[i++] = Position.y[eid];
      positions[i++] = Position.z[eid];
      if (i >= max * 3) break;
    }
  });

  return (
    <Points positions={positions} stride={3}>
      <PointMaterial color="#7fd7ff" size={0.02} sizeAttenuation />
    </Points>
  );
}
```

`App.tsx` just needs:

```diff
+import { Particles } from './Particles';

<Canvas>
  <Particles world={World} />
</Canvas>
```

---

## 2Â Â·Â WebGL: `GPUComputationRenderer` kernel

Add **one file**:

```ts
// packages/physics-sph/src/gpu/SphCompute.ts
import { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'; //Â îˆ€citeîˆ‚turn1search0îˆ
import { Scene, WebGLRenderer, DataTexture, RGBAFormat, FloatType } from 'three';

export function initSphGPGPU(renderer: WebGLRenderer, num: number, size = 128) {
  const gpuCompute = new GPUComputationRenderer(size, size, renderer);

  const pos0 = new DataTexture(new Float32Array(size * size * 4), size, size, RGBAFormat, FloatType);
  const vel0 = new DataTexture(new Float32Array(size * size * 4), size, size, RGBAFormat, FloatType);
  // TODO: seed textures with initial particle state â€¦

  const posVar = gpuCompute.addVariable('texturePosition', positionFragmentShader, pos0);
  const velVar = gpuCompute.addVariable('textureVelocity', velocityFragmentShader, vel0);

  gpuCompute.setVariableDependencies(posVar, [posVar, velVar]);
  gpuCompute.setVariableDependencies(velVar, [posVar, velVar]);

  gpuCompute.init();
  return gpuCompute;
}
```

*`positionFragmentShader`/`velocityFragmentShader` are 20â€‘line GLSL snippetsâ€”copy from the Three.js **boids** or **water** demo for now; weâ€™ll refine later.*

---

## 3Â Â·Â WebGPU: WGSL compute module

```wgsl
// packages/physics-sph/src/gpu/sph.wgsl
struct Particle { pos: vec4<f32>, vel: vec4<f32>, rho: f32, pad: vec3<f32> };

@group(0) @binding(0) var<storage, read_write> particles : array<Particle>;

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let i = gid.x;
  if (i >= arrayLength(&particles)) { return; }

  var p = particles[i];

  // naive gravity
  p.vel.y -= 9.81 * 0.016;
  p.pos.xyz += p.vel.xyz * 0.016;

  particles[i] = p;
}
```

Hook it from JavaScript with guidance from WebGPU samplesÂ îˆ€citeîˆ‚turn1search1îˆ‚turn1search3îˆ or fundamentalsÂ îˆ€citeîˆ‚turn1search8îˆ. The core already exposes a `registerComputePipeline()` helperâ€”pass WGSL source and a buffer, it schedules into the engineâ€™s frame loop.

---

## 4Â Â·Â Metadata for Leva autoâ€‘UI

```jsonc
// packages/physics-sph/metadata.json
{
  "displayName": "SPH Fluid",
  "controls": {
    "h":   { "value": 0.04,  "min": 0.01, "max": 0.1,   "step": 0.005 },
    "mu":  { "value": 0.1,   "min": 0.0,  "max": 2.0,   "step": 0.01 },
    "k":   { "value": 4,     "min": 0,    "max": 10,    "step": 0.1 },
    "g":   { "value": 9.81,  "min": 0,    "max": 20,    "step": 0.1 }
  }
}
```

The dashboardâ€™s `<ControlPanel>` walks each loaded module for `metadata.json` and autoâ€‘creates Leva foldersÂ îˆ€citeîˆ‚turn1search7îˆ.

---

## 5Â Â·Â Docs & Storybook stubs

```
apps/docs-site/docs/milestone-1-sph.mdx
packages/physics-sph/SphDemo.stories.tsx
```

Both can be oneâ€‘paragraph placeholders; CI will publish them so we keep the doc skeleton live.

---

## 6Â Â·Â Commit Sequence

```bash
git add apps/dashboard-app/src/Particles.tsx
git add packages/physics-sph/src/gpu/*
git add packages/physics-sph/metadata.json
git add apps/docs-site/docs/milestone-1-sph.mdx
git add packages/physics-sph/SphDemo.stories.tsx

git commit -m "feat: GPU compute pass, particles renderer, Leva metadata"
git push origin main
```

CI now:

1.Â Builds **CPU + WebGL + WebGPU** paths.  
2.Â Deploys automatic previewâ€”open the Vercel URL; youâ€™ll see **5Â k cyan particles** raining down.  
3.Â Leva sliders alter `h`, `mu`, etc. live via zustand.

---

### Whatâ€™s Next?

* **MilestoneÂ 2**Â â†’ unify CPU & GPU code paths; move density/pressure to GPU.  
* **MilestoneÂ 3**Â â†’ SDF collision (jumpâ€‘flood) + smooth metaball rendering.  
* **MilestoneÂ 4**Â â†’ switch SPH out, hotâ€‘add MPM package.

But firstâ€”paste the fresh preview link and letâ€™s confirm the first blob wobbles on your GPU. ğŸ«§ğŸ‰

*(All sources linked above demonstrate the viability of GPUComputationRendererÂ îˆ€citeîˆ‚turn1search0îˆ and WebGPU compute shaders for particlesÂ îˆ€citeîˆ‚turn1search1îˆ‚turn1search3îˆ‚turn1search8îˆ; Leva autoâ€‘UI relies on its React APIÂ îˆ€citeîˆ‚turn1search7îˆ.)*