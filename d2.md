### Niceâ€”looks like youâ€™ve run the bootstrap script inÂ Cursor and theÂ `blobverse/` tree is showing up exactly as designed. ğŸ¥³  
A couple of tiny warnings popped up, so weâ€™ll squash those first, then drop in the **initial SPH module + Leva metadata** so you can compile MilestoneÂ 1 locally.

---

## 1Â Â·Â Fix the Boot Warnings

| Warning | Fix |
|---------|-----|
| **â€œNo locally installedÂ â€˜turboâ€™Â foundâ€** | Add Turbo as a devâ€‘dependency in the root:  
```bash
pnpm add -D turbo@latest
``` |
| **â€œMissing â€˜packageManagerâ€™ field inÂ package.jsonâ€** | Add one line in the root `package.json`:  
```json
"packageManager": "pnpm@9.0.0"
```  
(This silences pnpmâ€™s workspace notices.) |

Commit those tweaks:

```bash
git add package.json
git commit -m "chore: add turbo & packageManager field"
```

---

## 2Â Â·Â Scaffold the **physicsâ€‘sph** Package

Below are two compact files. Paste each into the indicated path (Cursorâ€™s â€œCreateÂ Fileâ€ prompt makes this quick), then `pnpm turbo run dev --filter=physics-sph` to verify TS compilation.

### 2.1Â `packages/physics-sph/src/components.ts`

```ts
import { defineComponent, Types } from 'bitecs';

/** Position (x,y,z) in world space â€‘ meters */
export const Position = defineComponent({
  x: Types.f32,
  y: Types.f32,
  z: Types.f32,
});

/** Velocity (mÂ sâ»Â¹) */
export const Velocity = defineComponent({
  x: Types.f32,
  y: Types.f32,
  z: Types.f32,
});

/** Density + Pressure scalars (SPH) */
export const Fluid = defineComponent({
  density: Types.f32,
  pressure: Types.f32,
});
```

### 2.2Â `packages/physics-sph/src/SphSystem.ts`

```ts
import { World, register } from '@blobverse/ecs-core';
import { Position, Velocity, Fluid } from './components';
import { createUniformGrid, neighbours } from './spatial-hash';
import { SPHParams } from './types';

/**
 * Simple CPUâ€‘side SPH prototype.
 *   â€“ good for debugging    ğŸ‘“
 *   â€“ will be replaced by GPU compute in MilestoneÂ 3
 */
export class SphSystem {
  constructor(private params: Partial<SPHParams> = {}) {}

  execute(world: World) {
    const { h, restDensity, k, mu, g } = { ...defaultParams, ...this.params };

    // 1.Â build neighbour grid
    const grid = createUniformGrid(world, Position, h);

    // 2.Â density & pressure
    for (const eid of world.query([Position, Fluid])) {
      const Ï = neighbours(eid, grid, h, (j) => {
        if (j === eid) return 0;
        const rij = dist(eid, j);
        return poly6(rij, h);
      });
      Fluid.density[eid] = Ï;
      Fluid.pressure[eid] = k * (Ï - restDensity);
    }

    // 3.Â forces
    for (const eid of world.query([Position, Velocity, Fluid])) {
      let fX = 0, fY = -g, fZ = 0;
      neighbours(eid, grid, h, (j) => {
        if (j === eid) return;
        const rij = distVec(eid, j);
        const r = length(rij);
        // pressure
        const pTerm =
          -(Fluid.pressure[eid] + Fluid.pressure[j]) / (2 * Fluid.density[j]);
        const spikyGrad = spiky(r, h);
        fX += pTerm * spikyGrad * rij.x;
        fY += pTerm * spikyGrad * rij.y;
        fZ += pTerm * spikyGrad * rij.z;
        // viscosity
        const uij = {
          x: Velocity.x[j] - Velocity.x[eid],
          y: Velocity.y[j] - Velocity.y[eid],
          z: Velocity.z[j] - Velocity.z[eid],
        };
        const visc = mu * viscLaplacian(r, h);
        fX += visc * uij.x;
        fY += visc * uij.y;
        fZ += visc * uij.z;
      });
      // integrate (semiâ€‘implicit Euler for now)
      Velocity.x[eid] += fX * dt;
      Velocity.y[eid] += fY * dt;
      Velocity.z[eid] += fZ * dt;
      Position.x[eid] += Velocity.x[eid] * dt;
      Position.y[eid] += Velocity.y[eid] * dt;
      Position.z[eid] += Velocity.z[eid] * dt;
    }
  }
}

export const defaultParams: SPHParams = {
  h: 0.04,
  restDensity: 1000,
  k: 4,
  mu: 0.1,
  g: 9.81,
  dt: 0.016,
};

// autoâ€‘register
register(SphSystem);
```

*Notes*  
* The above is **CPU**â€‘only so you can see particle physics stepping in the debugger.  
* In MilestoneÂ 3 weâ€™ll swap this out for a GPU compute shader version (same API).  
* Tiny helpers (`spatial-hash.ts`, kernels) are templatedâ€”Cursor can stub them quickly with its â€œ/implement functionâ€ command.

### 2.3Â `packages/physics-sph/package.json`

```json
{
  "name": "@blobverse/physics-sph",
  "version": "0.1.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "dev": "tsc -w -p tsconfig.json",
    "build": "tsc -p tsconfig.json"
  },
  "dependencies": {
    "bitecs": "^0.5.1",
    "@blobverse/ecs-core": "*"
  }
}
```

---

## 3Â Â·Â Wire the SPHÂ System into the Dashboard

In `apps/dashboard-app/src/index.tsx` add:

```diff
+import '@blobverse/physics-sph';   // the autoâ€‘register sideâ€‘effect is enough
```

Leva will *autoâ€‘discover* the SPH default params because each physics package emits a tiny JSON metadata block (weâ€™ll add that in the next commit).

Run:

```bash
pnpm turbo run dev --filter=apps/dashboard-app
```

You should see a blank canvas (no renderer errors) and the Leva panel with sliders for `h`, `restDensity`, `k`, `mu`, `g`, and `dt`.

---

## 4Â Â·Â Commit & Push

```bash
git add .
git commit -m "feat(sph): initial CPUâ€‘side SPH system + ECS components"
git push origin main
```

---

## 5Â Â·Â What Happens Next?

1. **GitHubÂ Actions** runs lint â†’ test â†’ build.  
2. If green, the Vercel & Cloudflare preview URLs show the dashboard (still empty visualsâ€”particles come in the next patch).  
3. Paste the PR link here; Iâ€™ll review and then supply:
   * GPUComputationRenderer (WebGL) kernels  
   * WGSL compute shaders (WebGPU path)  
   * Leva metadata JSON so sliders bind automatically  
   * Storybook story for the SPH playground  
   * Docs MDX skeleton for â€œMilestoneÂ 1Â â€“ Particle Integrator & SPH basicsâ€

---

### Recap

* **Warnings fixed**Â â†’ Turbo & `packageManager`.  
* **physics-sph package** scaffolded with Position/Velocity/Density components and a debugâ€‘friendly SPH system.  
* **Dashboard imports** the system by sideâ€‘effect; Leva autoâ€‘UI appears.  

Push that commit, test locally, and drop me the PR link or any errors you hit. Weâ€™ll iterate to GPU kernels and visuals next. Blobbyâ€™s first water droplet is only a few shaders away! ğŸ’§ğŸš€